// ------------------------------------------------------------------------------
//  <auto-generated>
//     This code was generated by a tool (Spike Build).
//     Generated on: 16:57:31
//     Runtime Version: 4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//  </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Net;
using System.Linq;
using System.Runtime.Serialization;
using System.Collections.Generic;
using Spike;
using Spike.Hubs;
using Spike.Network;
using Spike.Network.Http;

namespace Spike.Network
{
   #region Class: StressProtocol
   ///<summary>
   /// Represents a static class that performs all the necessary initialization routines for StressProtocol.
   ///</summary>
   public static class StressProtocol
   {
      ///<summary>
      /// Performs the necessary configuration. This method is automatically invoked by Spike-Engine runtime.
      ///</summary>
      [InvokeAt(InvokeAtType.Configure)]
      public static void Configure()
      {

         // Signature: StressProtocol.Pull.GetAll.[ListOfComplexType].[]
         // Signature Digest: "B22E7270"
         PacketIndex.RegisterMetadata(new OperationInfo("B22E7270", true, null, CompressionTarget.None, Direction.Pull, null, null, typeof(GetAllInform), GetAllInform.CreateInstance));

         // Signature: StressProtocol.Pull.Check.[String.DynamicType.Boolean].[String.DynamicType]
         // Signature Digest: "70D7B183"
         PacketIndex.RegisterMetadata(new OperationInfo("70D7B183", true, null, CompressionTarget.None, Direction.Pull, typeof(CheckRequest), CheckRequest.CreateInstance, typeof(CheckInform), CheckInform.CreateInstance));

         // Signature: StressProtocol.Pull.Get.[DynamicType].[String]
         // Signature Digest: "3E05ECEE"
         PacketIndex.RegisterMetadata(new OperationInfo("3E05ECEE", true, null, CompressionTarget.None, Direction.Pull, typeof(GetRequest), GetRequest.CreateInstance, typeof(GetInform), GetInform.CreateInstance));

         // Signature: StressProtocol.Push.Event.[String.DateTime].[]
         // Signature Digest: "BA220D80"
         PacketIndex.RegisterMetadata(new OperationInfo("BA220D80", true, null, CompressionTarget.None, Direction.Push, null, null, typeof(EventInform), EventInform.CreateInstance));

         ProtocolInfo.Register("StressProtocol", "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjxQcm90b2NvbCBOYW1lPSJTdHJlc3NQcm90b2NvbCIgeG1sbnM9Imh0dHA6Ly93d3cuc3Bpa2UtZW5naW5lLmNvbS8yMDExL3NwbWwiIHhtbG5zOnhzaT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UiPg0KICA8T3BlcmF0aW9ucz4NCg0KICAgIDxPcGVyYXRpb24gTmFtZT0iR2V0QWxsIiBEaXJlY3Rpb249IlB1bGwiIFN1cHByZXNzU2VjdXJpdHk9InRydWUiPg0KICAgICAgPE91dGdvaW5nPg0KICAgICAgICA8TWVtYmVyIE5hbWU9IlRhYmxlIiBUeXBlPSJMaXN0T2ZDb21wbGV4VHlwZSIgQ2xhc3M9IlBhcmFtZXRlciI+DQogICAgICAgICAgPE1lbWJlciBOYW1lPSJLZXkiIFR5cGU9IlN0cmluZyIgLz4NCiAgICAgICAgICA8TWVtYmVyIE5hbWU9IlZhbHVlIiBUeXBlPSJEeW5hbWljVHlwZSIgLz4NCiAgICAgICAgPC9NZW1iZXI+DQogICAgICA8L091dGdvaW5nPg0KICAgIDwvT3BlcmF0aW9uPg0KDQogICAgPE9wZXJhdGlvbiBOYW1lPSJDaGVjayIgRGlyZWN0aW9uPSJQdWxsIiBTdXBwcmVzc1NlY3VyaXR5PSJ0cnVlIj4NCiAgICAgIDxJbmNvbWluZz4NCiAgICAgICAgPE1lbWJlciBOYW1lPSJLZXkiIFR5cGU9IlN0cmluZyIgLz4NCiAgICAgICAgPE1lbWJlciBOYW1lPSJWYWx1ZSIgVHlwZT0iRHluYW1pY1R5cGUiIC8+DQogICAgICA8L0luY29taW5nPg0KICAgICAgPE91dGdvaW5nPg0KICAgICAgICA8TWVtYmVyIE5hbWU9IktleSIgVHlwZT0iU3RyaW5nIiAvPg0KICAgICAgICA8TWVtYmVyIE5hbWU9IlZhbHVlIiBUeXBlPSJEeW5hbWljVHlwZSIgLz4NCiAgICAgICAgPE1lbWJlciBOYW1lPSJTdWNjZXNzIiBUeXBlPSJCb29sZWFuIiAvPg0KICAgICAgPC9PdXRnb2luZz4NCiAgICA8L09wZXJhdGlvbj4NCg0KICAgIDxPcGVyYXRpb24gTmFtZT0iR2V0IiBEaXJlY3Rpb249IlB1bGwiIFN1cHByZXNzU2VjdXJpdHk9InRydWUiPg0KICAgICAgPEluY29taW5nPg0KICAgICAgICA8TWVtYmVyIE5hbWU9IktleSIgVHlwZT0iU3RyaW5nIiAvPg0KICAgICAgPC9JbmNvbWluZz4NCiAgICAgIDxPdXRnb2luZz4NCiAgICAgICAgPE1lbWJlciBOYW1lPSJWYWx1ZSIgVHlwZT0iRHluYW1pY1R5cGUiIC8+DQogICAgICA8L091dGdvaW5nPg0KICAgIDwvT3BlcmF0aW9uPg0KDQogICAgPE9wZXJhdGlvbiBOYW1lPSJFdmVudCIgRGlyZWN0aW9uPSJQdXNoIiBTdXBwcmVzc1NlY3VyaXR5PSJ0cnVlIj4NCiAgICAgIDxPdXRnb2luZz4NCiAgICAgICAgPE1lbWJlciBOYW1lPSJNZXNzYWdlIiBUeXBlPSJTdHJpbmciIC8+DQogICAgICAgIDxNZW1iZXIgTmFtZT0iVGltZSIgVHlwZT0iRGF0ZVRpbWUiIC8+DQogICAgICA8L091dGdvaW5nPg0KICAgIDwvT3BlcmF0aW9uPg0KDQogIDwvT3BlcmF0aW9ucz4NCjwvUHJvdG9jb2w+");
      }

      ///<summary>
      /// Performs the necessary initaliazation. This method is automatically invoked by Spike-Engine runtime.
      ///</summary>
      [InvokeAt(InvokeAtType.Initialize)]
      public static void Initialize()
      {

         // StressProtocol.Pull.GetAll.[ListOfComplexType].[]
         PacketHandlers.Register("B22E7270", InternalGetAll);

         // StressProtocol.Pull.Check.[String.DynamicType.Boolean].[String.DynamicType]
         PacketHandlers.Register("70D7B183", InternalCheck);

         // StressProtocol.Pull.Get.[DynamicType].[String]
         PacketHandlers.Register("3E05ECEE", InternalGet);
      }
      ///<summary>
      /// Event that is invoked when a request for GetAll operation comes in.
      ///</summary>
      public static event RequestHandler GetAll;

      private static void InternalGetAll(IClient client, Packet requestPacket)
      {
         if(GetAll != null)
            GetAll(client);
      }
      ///<summary>
      /// Event that is invoked when a request for Check operation comes in.
      ///</summary>
      public static event RequestHandler<CheckRequest> Check;

      private static void InternalCheck(IClient client, Packet requestPacket)
      {
         CheckRequest request = requestPacket as CheckRequest;
         if(Check != null)
            Check(client, request);
      }
      ///<summary>
      /// Event that is invoked when a request for Get operation comes in.
      ///</summary>
      public static event RequestHandler<GetRequest> Get;

      private static void InternalGet(IClient client, Packet requestPacket)
      {
         GetRequest request = requestPacket as GetRequest;
         if(Get != null)
            Get(client, request);
      }
   }
   #endregion

   #region Class: StressProtocolExtensions
   ///<summary>
   /// Represents a static class that contains IClient extension methods for StressProtocol.
   ///</summary>
   public static class StressProtocolExtensions
   {
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IClient client, IList<Parameter> Table)
      {
         GetAllInform packet = GetAllInform.Metadata.AcquireInform() as GetAllInform;
         packet.Table = Table;
         client.Send(packet);
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IClient client, GetAllInform packet)
      {
         client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IClient[] clients, IList<Parameter> Table)
      {
         using(GetAllInform packet = GetAllInform.Metadata.AcquireInform() as GetAllInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Table = Table;
            for (int i = 0; i < clients.Length; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IClient[] clients, GetAllInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Length; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this List<IClient> clients, IList<Parameter> Table)
      {
         using(GetAllInform packet = GetAllInform.Metadata.AcquireInform() as GetAllInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Table = Table;
            for (int i = 0; i < clients.Count; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this List<IClient> clients, GetAllInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Count; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IEnumerable<IClient> clients, IList<Parameter> Table)
      {
         using(GetAllInform packet = GetAllInform.Metadata.AcquireInform() as GetAllInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Table = Table;
            foreach(var client in clients)
               client.Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetAllInform(this IEnumerable<IClient> clients, GetAllInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         foreach(var client in clients)
            client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IClient client, String Key, Object Value, Boolean Success)
      {
         CheckInform packet = CheckInform.Metadata.AcquireInform() as CheckInform;
         packet.Key = Key;
         packet.Value = Value;
         packet.Success = Success;
         client.Send(packet);
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IClient client, CheckInform packet)
      {
         client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IClient[] clients, String Key, Object Value, Boolean Success)
      {
         using(CheckInform packet = CheckInform.Metadata.AcquireInform() as CheckInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Key = Key;
            packet.Value = Value;
            packet.Success = Success;
            for (int i = 0; i < clients.Length; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IClient[] clients, CheckInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Length; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this List<IClient> clients, String Key, Object Value, Boolean Success)
      {
         using(CheckInform packet = CheckInform.Metadata.AcquireInform() as CheckInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Key = Key;
            packet.Value = Value;
            packet.Success = Success;
            for (int i = 0; i < clients.Count; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this List<IClient> clients, CheckInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Count; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IEnumerable<IClient> clients, String Key, Object Value, Boolean Success)
      {
         using(CheckInform packet = CheckInform.Metadata.AcquireInform() as CheckInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Key = Key;
            packet.Value = Value;
            packet.Success = Success;
            foreach(var client in clients)
               client.Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendCheckInform(this IEnumerable<IClient> clients, CheckInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         foreach(var client in clients)
            client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IClient client, Object Value)
      {
         GetInform packet = GetInform.Metadata.AcquireInform() as GetInform;
         packet.Value = Value;
         client.Send(packet);
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IClient client, GetInform packet)
      {
         client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IClient[] clients, Object Value)
      {
         using(GetInform packet = GetInform.Metadata.AcquireInform() as GetInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Value = Value;
            for (int i = 0; i < clients.Length; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IClient[] clients, GetInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Length; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this List<IClient> clients, Object Value)
      {
         using(GetInform packet = GetInform.Metadata.AcquireInform() as GetInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Value = Value;
            for (int i = 0; i < clients.Count; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this List<IClient> clients, GetInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Count; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IEnumerable<IClient> clients, Object Value)
      {
         using(GetInform packet = GetInform.Metadata.AcquireInform() as GetInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Value = Value;
            foreach(var client in clients)
               client.Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendGetInform(this IEnumerable<IClient> clients, GetInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         foreach(var client in clients)
            client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IClient client, String Message, DateTime Time)
      {
         EventInform packet = EventInform.Metadata.AcquireInform() as EventInform;
         packet.Message = Message;
         packet.Time = Time;
         client.Send(packet);
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IClient client, EventInform packet)
      {
         client.Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IClient[] clients, String Message, DateTime Time)
      {
         using(EventInform packet = EventInform.Metadata.AcquireInform() as EventInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Message = Message;
            packet.Time = Time;
            for (int i = 0; i < clients.Length; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IClient[] clients, EventInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Length; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this List<IClient> clients, String Message, DateTime Time)
      {
         using(EventInform packet = EventInform.Metadata.AcquireInform() as EventInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Message = Message;
            packet.Time = Time;
            for (int i = 0; i < clients.Count; ++i)
               clients[i].Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this List<IClient> clients, EventInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         for (int i = 0; i < clients.Count; ++i)
            clients[i].Send(packet);
      }
      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IEnumerable<IClient> clients, String Message, DateTime Time)
      {
         using(EventInform packet = EventInform.Metadata.AcquireInform() as EventInform)
         {
            packet.Lifetime = PacketLifetime.Manual;
            packet.Message = Message;
            packet.Time = Time;
            foreach(var client in clients)
               client.Send(packet);
         }
      }

      /// <summary>
      /// Sents a reply to the operation: 
      /// </summary>
      public static void SendEventInform(this IEnumerable<IClient> clients, EventInform packet)
      {
         packet.Lifetime = PacketLifetime.Manual;
         foreach(var client in clients)
            client.Send(packet);
      }
   }
   #endregion

   #region Class: StressProtocolHubBase
   ///<summary>
   /// Represents an optional, abstract hub class for StressProtocol.
   ///</summary>
   public abstract class StressProtocolHubBase : Hub
   {
      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class. The instance will be locked
      /// with a default randomly generated publish key.
      /// </summary>
      public StressProtocolHubBase() : base()
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class. The instance will be locked
      /// with a default randomly generated publish key.
      /// </summary>
      /// <param name="name">The name of the hub.</param>
      public StressProtocolHubBase(string name) : base(name)
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class. The instance will be locked with a 
      /// default randomly generated publish key.
      /// </summary>
      /// <param name="autoRegister">Whether the hub should be automatically registered in the provider or not.</param>
      /// <param name="name">The name of the hub.</param>
      public StressProtocolHubBase(string name, bool autoRegister)
          : base(name, autoRegister)
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class. 
      /// </summary>
      /// <param name="name">The name of the hub.</param>
      /// <param name="defaultPublishKey">The default publish key to apply to this hub.</param>
      /// <param name="defaultSubscribeKey">The default subscribe key to apply to this hub.</param>
      public StressProtocolHubBase(string name, string defaultPublishKey, string defaultSubscribeKey)
          : base(name, defaultPublishKey, defaultSubscribeKey)
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class.
      /// </summary>
      /// <param name="name">The name of the hub.</param>
      /// <param name="defaultPublishKey">The default publish key to apply to this hub.</param>
      public StressProtocolHubBase(string name, string defaultPublishKey)
          : base(name, defaultPublishKey)
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class.
      /// </summary>
      /// <param name="name">The name of the hub.</param>
      /// <param name="defaultPublishKey">The default publish key to apply to this hub.</param>
      /// <param name="autoRegister">Whether the hub should be automatically registered in the provider or not.</param>
      public StressProtocolHubBase(string name, string defaultPublishKey, bool autoRegister)
          : base(name, defaultPublishKey, autoRegister)
      {
      }

      /// <summary>
      /// Constructs a new instance of a <see cref="StressProtocolHubBase"/> class.
      /// </summary>
      /// <param name="name">The name of the hub.</param>
      /// <param name="defaultPublishKey">The default publish key to apply to this hub.</param>
      /// <param name="defaultSubscribeKey">The default subscribe key to apply to this hub.</param>
      /// <param name="autoRegister">Whether the hub should be automatically registered in the provider or not.</param>
      public StressProtocolHubBase(string name, string defaultPublishKey, string defaultSubscribeKey, bool autoRegister)
          : base(name, defaultPublishKey, defaultSubscribeKey,  autoRegister)
      {
      }

      /// <summary>
      /// Invoked when a new instance of a <see cref="Hub"/> is constructed.
      /// </summary>
      protected override void OnAfterConstruct()
      {
         // Call the base
         base.OnAfterConstruct();

         // Hook the handlers
         StressProtocol.GetAll += this.OnGetAll;
         StressProtocol.Check += this.OnCheck;
         StressProtocol.Get += this.OnGet;
      }

      /// <summary>
      /// Releases the unmanaged resources used by the ByteSTream class and optionally releases the managed resources.
      /// </summary>
      /// <param name="disposing">If set to true, release both managed and unmanaged resources, othewise release only unmanaged resources. </param>
      protected override void Dispose(bool disposing)
      {
         // Call the base
         base.Dispose(disposing);
         
         // Unhook the handlers.
         StressProtocol.GetAll -= this.OnGetAll;
         StressProtocol.Check -= this.OnCheck;
         StressProtocol.Get -= this.OnGet;
      }


      /// <summary>
      /// Invoked when an incoming request for GetAll operation comes in.
      /// </summary>
      public abstract void OnGetAll(IClient client);

      /// <summary>
      /// Invoked when an incoming request for Check operation comes in.
      /// </summary>
      public abstract void OnCheck(IClient client, CheckRequest packet);

      /// <summary>
      /// Invoked when an incoming request for Get operation comes in.
      /// </summary>
      public abstract void OnGet(IClient client, GetRequest packet);
   }
   #endregion

   #region ComplexType: Parameter
   /// <summary>
   /// Complex type Parameter. 
   /// </summary>
   public struct Parameter : IComplexType
   {

      /// <summary>
      /// Creates a new instance of the complex type by deserializing from a binary stream.
      /// </summary>
      /// <param name="Reader">The PacketReader that should be used to deserialize.</param>
      public Parameter(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
         this.Value = Reader.ReadDynamic();
      }

      /// <summary>
      /// Creates a new instance of complex type by initializing all its fields.
      /// </summary>
      /// <param name="Key">The value for Key field.</param>
      /// <param name="Value">The value for Value field.</param>
      public Parameter(String Key, Object Value)
      {
         this.Key = Key;
         this.Value = Value;
      }

      /// <summary>
      /// Gets or sets the Key field. 
      /// </summary>
      public String Key;

      /// <summary>
      /// Gets or sets the Value field. 
      /// </summary>
      public Object Value;

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      /// <param name="Writer">The PacketWriter that should be used for serialization.</param>
      public void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
         Writer.WriteDynamic(Value);
      }

      /// <summary>
      /// Deserializes this complex type from a binary stream.
      /// </summary>
      /// <param name="Reader">The PacketReader that should be used for deserialization.</param>
      public void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
         this.Value = Reader.ReadDynamic();
      }
   }
   #endregion

   #region Packet: CheckRequest
   /// <summary>
   /// CheckRequest defines a packet container object for the Check operation.
   /// </summary>
   public sealed class CheckRequest: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public CheckRequest() : base(PacketKey.Get("70D7B183"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public CheckRequest(String Key, Object Value) : base(PacketKey.Get("70D7B183"))
      {
         this.Key = Key;
         this.Value = Value;
      }


      /// <summary>
      /// Gets or sets the Key field. 
      /// </summary>
      public String Key;

      /// <summary>
      /// Gets or sets the Value field. 
      /// </summary>
      public Object Value;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Incoming; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
         Writer.WriteDynamic(Value);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
         this.Value = Reader.ReadDynamic();
      }

      /// <summary>
      /// A factory method that constructs an instance of CheckRequest packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new CheckRequest();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("70D7B183");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion

   #region Packet: GetRequest
   /// <summary>
   /// GetRequest defines a packet container object for the Get operation.
   /// </summary>
   public sealed class GetRequest: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public GetRequest() : base(PacketKey.Get("3E05ECEE"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public GetRequest(String Key) : base(PacketKey.Get("3E05ECEE"))
      {
         this.Key = Key;
      }


      /// <summary>
      /// Gets or sets the Key field. 
      /// </summary>
      public String Key;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Incoming; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
      }

      /// <summary>
      /// A factory method that constructs an instance of GetRequest packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new GetRequest();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("3E05ECEE");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion

   #region Packet: GetAllInform
   /// <summary>
   /// GetAllInform defines a packet container object for the GetAll operation.
   /// </summary>
   public sealed class GetAllInform: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public GetAllInform() : base(PacketKey.Get("B22E7270"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public GetAllInform(IList<Parameter> Table) : base(PacketKey.Get("B22E7270"))
      {
         this.Table = Table;
      }


      /// <summary>
      /// Gets or sets the Table field. 
      /// </summary>
      public IList<Parameter> Table;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Outgoing; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.Write<Parameter>(Table);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Table = Reader.ReadListOfComplexType<Parameter>();
      }

      /// <summary>
      /// A factory method that constructs an instance of GetAllInform packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new GetAllInform();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("B22E7270");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion

   #region Packet: CheckInform
   /// <summary>
   /// CheckInform defines a packet container object for the Check operation.
   /// </summary>
   public sealed class CheckInform: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public CheckInform() : base(PacketKey.Get("70D7B183"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public CheckInform(String Key, Object Value, Boolean Success) : base(PacketKey.Get("70D7B183"))
      {
         this.Key = Key;
         this.Value = Value;
         this.Success = Success;
      }


      /// <summary>
      /// Gets or sets the Key field. 
      /// </summary>
      public String Key;

      /// <summary>
      /// Gets or sets the Value field. 
      /// </summary>
      public Object Value;

      /// <summary>
      /// Gets or sets the Success field. 
      /// </summary>
      public Boolean Success;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Outgoing; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
         Writer.WriteDynamic(Value);
         Writer.Write(Success);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
         this.Value = Reader.ReadDynamic();
         this.Success = Reader.ReadBoolean();
      }

      /// <summary>
      /// A factory method that constructs an instance of CheckInform packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new CheckInform();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("70D7B183");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion

   #region Packet: GetInform
   /// <summary>
   /// GetInform defines a packet container object for the Get operation.
   /// </summary>
   public sealed class GetInform: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public GetInform() : base(PacketKey.Get("3E05ECEE"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public GetInform(Object Value) : base(PacketKey.Get("3E05ECEE"))
      {
         this.Value = Value;
      }


      /// <summary>
      /// Gets or sets the Value field. 
      /// </summary>
      public Object Value;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Outgoing; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.WriteDynamic(Value);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Value = Reader.ReadDynamic();
      }

      /// <summary>
      /// A factory method that constructs an instance of GetInform packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new GetInform();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("3E05ECEE");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion

   #region Packet: EventInform
   /// <summary>
   /// EventInform defines a packet container object for the Event operation.
   /// </summary>
   public sealed class EventInform: SecpPacket
   {

      /// <summary>
      /// Creates a new empty instance of the packet
      /// </summary>
      public EventInform() : base(PacketKey.Get("BA220D80"))
      {
      }

      /// <summary>
      /// Creates a new instance of the packet by initializing all its fields
      /// </summary>
      public EventInform(String Message, DateTime Time) : base(PacketKey.Get("BA220D80"))
      {
         this.Message = Message;
         this.Time = Time;
      }


      /// <summary>
      /// Gets or sets the Message field. 
      /// </summary>
      public String Message;

      /// <summary>
      /// Gets or sets the Time field. 
      /// </summary>
      public DateTime Time;

      /// <summary>
      /// Gets the direction of the packet: whether the first 
      /// call is initiated on server (Push) or client (Pull)
      /// </summary>
      public sealed override PacketDirection Direction
      {
         get { return PacketDirection.Outgoing; } 
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Write(PacketWriter Writer)
      {
         Writer.Write(Message);
         Writer.Write(Time);
      }

      /// <summary>
      /// Serializes this complex type to a binary stream.
      /// </summary>
      public override void Read(PacketReader Reader)
      {
         this.Message = Reader.ReadString();
         this.Time = Reader.ReadDateTime();
      }

      /// <summary>
      /// A factory method that constructs an instance of EventInform packet.
      /// </summary>
      public static Packet CreateInstance()
      {
         return new EventInform();
      }

      /// <summary>
      /// Gets the metadata for the operation which contains the given packet type.
      /// </summary>
      public static OperationInfo Metadata
      {
         get
         {
            if(OpInfo == null)
            {
               OpInfo = PacketIndex.GetMetadata("BA220D80");
            }
            return OpInfo;
         }
      }

      /// <summary>
      /// Cached metadata reference for faster access. 
      /// </summary>
      private static OperationInfo OpInfo = null;
   }
   #endregion
}
