// ------------------------------------------------------------------------------
//  <auto-generated>
//     This code was generated by a tool (Spike Build).
//     Runtime Version: 4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//  </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Runtime.Serialization;
using System.Threading;
using System.Security.Cryptography;
using System.Net;
using System.Net.Sockets;
using System.IO.Compression;

namespace Spike.Network
{



    #region BasePool Class
    internal abstract class BasePool<T> : IEnumerable<T>, IDisposable
    {

        /// <summary>
        /// Number of elements in the array (including dirty ones)
        /// </summary>
        public int RawCount;

        /// <summary>
        /// Number of used elements in the array
        /// </summary>
        public int Count;

        /// <summary>
        /// Underlying items array
        /// </summary>
        public T[] Items;

        protected int FreeListCount;
        protected int[] FreeList;
        protected byte[] UsedList;

        public BasePool()
        {
            this.Items = new T[4];
            this.FreeList = new int[4];
            this.UsedList = new byte[4];
        }

        public BasePool(int initialCapacity)
        {
            this.Items = new T[initialCapacity];
            this.FreeList = new int[initialCapacity];
            this.UsedList = new byte[initialCapacity];
        }


        /// <summary>
        /// Finds a new, not allocated spot
        /// </summary>
        protected int GetFreeIndex()
        {
            int handle = this.RawCount;
            if (handle < this.Items.Length)
            {
                if (Equals(this.Items[handle], default(T)))
                    return handle;
                else
                {
                    int len = this.Items.Length;
                    for (int i = handle; i < len; ++i)
                    {
                        if (Equals(this.Items[handle], default(T)))
                            return handle;
                    }
                }
            }

            // have to reallocate
            int newSize = this.RawCount;
            newSize |= newSize >> 1;
            newSize |= newSize >> 2;
            newSize |= newSize >> 4;
            newSize |= newSize >> 8;
            newSize |= newSize >> 16;
            newSize++;

            Array.Resize(ref this.Items, newSize);
            Array.Resize(ref this.UsedList, newSize);

            return handle;

        }

        /// <summary>
        /// Sets an item to a particular position in the array and marks as used
        /// </summary>
        public virtual void SetItem(int handle, T item)
        {
            this.Items[handle] = item;
            this.SetAsUsed(handle);
        }

        /// <summary>
        /// Set an item as used at a particular handle (in the case the search algorithm is handled differently)
        /// </summary>
        /// <param name="item">Acquired item</param>
        /// <param name="handle">handle to acquire at</param>
        protected void SetAsUsed(int handle)
        {
            if (this.UsedList[handle] == 0)
            {
                this.UsedList[handle] = 1;

                if (handle >= this.RawCount)
                {
                    // have to reallocate
                    int newSize = this.RawCount;
                    newSize |= newSize >> 1;
                    newSize |= newSize >> 2;
                    newSize |= newSize >> 4;
                    newSize |= newSize >> 8;
                    newSize |= newSize >> 16;
                    newSize++;

                    Array.Resize(ref this.Items, newSize);
                    Array.Resize(ref this.UsedList, newSize);
                }
                else
                {
                    if (this.FreeListCount == 1 && this.FreeList[0] == handle)
                    {
                        FreeListCount = 0;
                    }
                    else if (FreeListCount > 1)
                    {
                        // Remove from the free list
                        RemoveArrayItem<int>(ref this.FreeList, handle);
                        this.FreeListCount--;
                    }
                }
            }
        }

        private static int RemoveArrayItem<K>(ref K[] array, K removedItem)
        {
            int count = array.Length;

            if (count == 0)
                return -1;

            for (int i = 0; i < count; ++i)
            {
                if (!Equals(array[i], removedItem))
                    continue;

                K[] newArray = new K[count - 1];
                Array.Copy(array, 0, newArray, 0, i);
                Array.Copy(array, i + 1, newArray, i, count - i - 1);
                array = newArray;

                return i;
            }

            return -1;
        }

        /// <summary>
        /// Checks whether there is an element in use at a given position
        /// </summary>
        /// <param name="handle">The handle to check</param>
        /// <returns>True if there is an element in this position, otherwise false</returns>
        public bool HasElementAt(int handle)
        {
            return this.UsedList[handle] == 1;
        }


        #region IDisposable Members

        /// <summary>
        /// Frees the pool, deallocates the reserved memory
        /// </summary>
        public void FreeAll()
        {
            int count = this.RawCount;
            for (int i = 0; i < count; ++i)
                this.Items[i] = default(T); // set to default

            this.RawCount = 0;
            this.FreeListCount = 0;
        }

        /// <summary>
        /// Disposes the object
        /// </summary>
        public void Dispose()
        {
            FreeAll();
        }

        #endregion

        #region IEnumerable<T> Members

        public IEnumerator<T> GetEnumerator()
        {
            return new PoolCursor(this, 0, PoolCursorBehavior.Stop);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PoolCursor(this, 0, PoolCursorBehavior.Stop);
        }

        #endregion

        #region Nested Iterator

        public enum PoolCursorBehavior
        {
            /// <summary>
            /// The cursor will stop when it has reached the end (beginning)
            /// </summary>
            Stop,
            /// <summary>
            /// The cursor will loop when it has reached the end (beginning)
            /// </summary>
            Loop
        }

        public struct PoolCursor : IEnumerator<T>
        {
            /// <summary>
            /// Underlying items array
            /// </summary>
            public BasePool<T> PoolRef;

            /// <summary>
            /// Currently selected handle
            /// </summary>
            public int SelectedHandle;

            /// <summary>
            /// Behavior for this cursor
            /// </summary>
            public PoolCursorBehavior Behavior;

            #region Constructors
            public PoolCursor(BasePool<T> poolRef)
            {
                this.PoolRef = poolRef;
                this.SelectedHandle = 0;
                Behavior = PoolCursorBehavior.Stop;
            }

            public PoolCursor(BasePool<T> poolRef, PoolCursorBehavior behavior)
            {
                this.PoolRef = poolRef;
                this.SelectedHandle = 0;
                Behavior = behavior;
            }

            public PoolCursor(BasePool<T> poolRef, int startingPosition)
            {
                this.PoolRef = poolRef;
                this.SelectedHandle = startingPosition;
                Behavior = PoolCursorBehavior.Stop;
            }

            public PoolCursor(BasePool<T> poolRef, int startingPosition, PoolCursorBehavior behavior)
            {
                this.PoolRef = poolRef;
                this.SelectedHandle = startingPosition;
                Behavior = behavior;
            }
            #endregion

            #region IEnumerator<T> Members

            public T Current
            {
                get
                {
                    if (this.PoolRef.Count == 0) // No elements, return default
                        return default(T);
                    return this.PoolRef.Items[this.SelectedHandle];
                }
            }


            object System.Collections.IEnumerator.Current
            {
                get
                {
                    if (this.PoolRef.Count == 0) // No elements, return default
                        return default(T);
                    return this.PoolRef.Items[this.SelectedHandle];
                }
            }

            public bool MoveNext()
            {
                int elems = this.PoolRef.Count;
                if (elems == 0) // No elements, can not move
                    return false;

                int count = PoolRef.RawCount;
                T[] items = PoolRef.Items;
                if (elems == 1 && this.PoolRef.HasElementAt(this.SelectedHandle)) // One element and it's already selected
                    return false;

                if (elems == 1) // One element, but the selected is dirty
                {
                    for (int i = 0; i < count; ++i)
                    {
                        if (!PoolRef.HasElementAt(i))
                            continue;
                        this.SelectedHandle = i;
                        return true; // we found the element
                    }
                    return false;
                }

                // Standard move next
                for (int i = this.SelectedHandle + 1; i < count; ++i)
                {
                    if (!PoolRef.HasElementAt(i))
                        continue;
                    this.SelectedHandle = i;
                    return true;
                }

                if (this.Behavior == PoolCursorBehavior.Stop)
                    return false;
                else // Loop from the beginning
                {
                    for (int i = 0; i < this.SelectedHandle; ++i)
                    {
                        if (!PoolRef.HasElementAt(i))
                            continue;
                        this.SelectedHandle = i;
                        return true;
                    }
                    return false;
                }
            }

            public void Reset()
            {
                int elems = this.PoolRef.Count;
                if (elems == 0)
                {
                    // No elements in the array, can't reset
                    SelectedHandle = 0;
                }
                else
                {
                    // Find first element
                    int count = this.PoolRef.RawCount;
                    T[] items = this.PoolRef.Items;
                    for (int i = 0; i < count; ++i)
                    {
                        if (!PoolRef.HasElementAt(i))
                            continue;
                        SelectedHandle = i;
                        return;
                    }
                }
            }

            public void Dispose()
            {
                // why there's always a dispose for an interator? crappy thing
            }

            #endregion

        }
        #endregion
    }
    #endregion

    internal class BufferPool : BasePool<byte[]>
    {
        private int fBufferSize;
        public BufferPool(int initialCapacity, int bufferSize)
            : base(initialCapacity)
        {
            fBufferSize = bufferSize;
            for (int i = 0; i < initialCapacity; ++i)
            {
                this.Items[i] = new byte[bufferSize];
                this.FreeList[i] = i;
                this.UsedList[i] = 0;
            }

            this.RawCount = initialCapacity;
            this.FreeListCount = initialCapacity;
            this.Count = 0;
        }

        /// <summary>
        /// Acquires an instance of byte[] and returns the reference to the instance
        /// as well as the handle in the Pool
        /// </summary>
        /// <param name="item">Reference to the recently acquired instance of byte[]</param>
        /// <returns>The handle in the Pool (index in the internal array)</returns>
        public int Acquire(out byte[] item)
        {
            lock (this.Items)
            {
                if (this.FreeListCount > 0)
                {
                    this.FreeListCount--;
                    int handle = this.FreeList[this.FreeListCount];
                    this.UsedList[handle] = 1;
                    this.Count++;

                    if (this.Items[handle] == null)
                    {
                        item = new byte[this.fBufferSize];
                        this.Items[handle] = item;
                        return handle;
                    }

                    item = this.Items[handle];
                    return handle;
                }
                else
                {
                    int handle = this.RawCount;
                    if (handle < this.Items.Length)
                    {
                        this.UsedList[handle] = 1;
                        this.Count++;

                        if (this.Items[handle] == null)
                        {
                            item = new byte[this.fBufferSize];
                            this.Items[handle] = item;
                            this.RawCount++;
                            return handle;
                        }

                        item = this.Items[handle];
                        this.RawCount++;
                        return handle;
                    }
                    else
                    {
                        // have to reallocate
                        int newSize = this.RawCount;
                        newSize |= newSize >> 1;
                        newSize |= newSize >> 2;
                        newSize |= newSize >> 4;
                        newSize |= newSize >> 8;
                        newSize |= newSize >> 16;
                        newSize++;

                        Array.Resize(ref this.Items, newSize);
                        Array.Resize(ref this.UsedList, newSize);

                        item = new byte[this.fBufferSize];
                        this.Items[handle] = item;
                        this.UsedList[handle] = 1;
                        this.Count++;
                        this.RawCount++;
                        return handle;
                    }
                }
            }
        }

        /// <summary>
        /// Acquires an instance of byte[] and returns the reference to the instance
        /// as well as the handle in the Pool
        /// </summary>
        /// <param name="item">Reference to the recently acquired instance of byte[]</param>
        /// <returns>The handle in the Pool (index in the internal array)</returns>
        public int Acquire(out byte[] buffer, int minimumLength)
        {
            lock (this.Items)
            {
                buffer = null;
                int handle = 0;

                if (this.FreeListCount > 0) // Check the free list
                {
                    // goes through freed items
                    for (int i = 0; i < this.FreeListCount; ++i)
                    {
                        // satisfies the length condition?
                        handle = this.FreeList[i];
                        if (this.Items[handle].Length >= minimumLength)
                        {
                            // Overwrite the current number with the last one
                            this.FreeList[i] = this.FreeList[--this.FreeListCount];
                            this.UsedList[handle] = 1;
                            this.Count++;

                            // Return the buffer
                            buffer = this.Items[handle];
                            return handle;
                        }
                    }
                }

                // Not found in free buffers, allocate
                handle = this.RawCount;
                if (handle < this.Items.Length)
                {
                    // Return a new buffer
                    buffer = AllocateBuffer(handle, minimumLength);
                    return handle;
                }
                else
                {
                    // have to reallocate
                    int newSize = this.RawCount;
                    newSize |= newSize >> 1;
                    newSize |= newSize >> 2;
                    newSize |= newSize >> 4;
                    newSize |= newSize >> 8;
                    newSize |= newSize >> 16;
                    newSize++;

                    Array.Resize(ref this.Items, newSize);
                    Array.Resize(ref this.UsedList, newSize);

                    // Return a new buffer
                    buffer = AllocateBuffer(handle, minimumLength);
                    return handle;
                }
            }
        }

        private byte[] AllocateBuffer(int handle, int minimumLength)
        {
            // Compute the size of the new buffer
            int newBufferSize = minimumLength;
            newBufferSize |= newBufferSize >> 1;
            newBufferSize |= newBufferSize >> 2;
            newBufferSize |= newBufferSize >> 4;
            newBufferSize |= newBufferSize >> 8;
            newBufferSize |= newBufferSize >> 16;
            newBufferSize++;

            // Allocate the buffer
            byte[] buffer = new byte[newBufferSize];
            this.Items[handle] = buffer;

            // Set the used list index & increment counters 
            this.UsedList[handle] = 1;
            this.RawCount++;
            this.Count++;

            return buffer;
        }

        /// <summary>
        /// Releases the instance of T specified by the handle
        /// </summary>
        /// <param name="handle"></param>
        public void Release(int handle)
        {
            lock (this.Items)
            {
                if (this.UsedList[handle] == 0)
                    return; // the spot is already free

                this.UsedList[handle] = 0;
                this.Count--;

                if (this.FreeListCount < this.FreeList.Length)
                {
                    this.FreeList[this.FreeListCount++] = handle;
                    return;
                }

                // have to reallocate
                int newSize = this.FreeListCount;
                newSize |= newSize >> 1;
                newSize |= newSize >> 2;
                newSize |= newSize >> 4;
                newSize |= newSize >> 8;
                newSize |= newSize >> 16;
                newSize++;

                Array.Resize(ref this.FreeList, newSize);
                this.FreeList[this.FreeListCount] = handle;
                this.FreeListCount++;
            }
        }

        /// <summary>
        /// Gets the buffer by its handle
        /// </summary>
        /// <param name="handle">The handle to get</param>
        /// <returns>Returns the buffer if one can be used, otherwize null</returns>
        public byte[] GetBuffer(int handle)
        {
            if (this.UsedList[handle] == 0)
                return null; // the spot is free
            return this.Items[handle];
        }

        /// <summary>
        /// Clears the pool without deallocating
        /// </summary>
        public void Clear()
        {
            int count = this.RawCount;
            for (int i = 0; i < count; ++i)
            {
                if (this.UsedList[i] == 1)
                    Release(i);
            }
        }
    }



    /// <summary>
    /// An abstract class that represents a communication channel with a remote end point.
    /// </summary>
    public abstract class ChannelBase 
    {
        #region Properties
        private IPacketEncoder fPacketEncoder;
        protected bool fDisconnected = true;
        protected EndPoint fEndPoint;
        protected Uri fServerUri;
        protected string fProtocol = "";

        /// <summary>
        /// Gets or sets remote server end point.
        /// </summary>
        public virtual EndPoint EndPoint
        {
            get { return fEndPoint; }
            set
            {
                fEndPoint = value;
                fServerUri = new Uri(fProtocol + "://" + fEndPoint.ToString());
            }
        }

        /// <summary>
        /// Gets or sets remote server end point by Uri.
        /// </summary>
        public virtual Uri ServerUri
        {
            get { return fServerUri; }
            set 
            {
                fEndPoint  = ParseEndPoint(value.Host, value.Port);
                fServerUri = value;
            }
        }

        /// <summary>
        /// Gets or sets the packet encoder for this channel.
        /// </summary>
        public virtual IPacketEncoder PacketEncoder
        {
            get { return fPacketEncoder; }
            set { fPacketEncoder = value; }
        }

        #endregion

        /// <summary>
        /// Constructs a new instance of <see cref="ChannelBase"/> class.
        /// </summary>
        /// <param name="protocol">The communication protocol for this channel.</param>
        public ChannelBase(string protocol)
        {
            fProtocol = protocol;
        }

        #region Public Methods
        /// <summary>
        /// Performs a connection to the remote server
        /// </summary>
        /// <param name="host">Hostname to connect to</param>
        /// <param name="port">Port to connect through</param>
        public virtual void Connect(string host, int port) 
        {
            fEndPoint = ParseEndPoint(host, port);
            fServerUri = new Uri(fProtocol + "://" + fEndPoint.ToString());
            Connect();
        }

        /// <summary>
        /// Performs a connection to the remote server
        /// </summary>
        /// <param name="serverUri">Server Uri to connect to, must contain host name and the port</param>
        public virtual void Connect(Uri serverUri)
        {
            fEndPoint = ParseEndPoint(serverUri.Host, serverUri.Port);
            fServerUri = serverUri;
            Connect();
        }

        /// <summary>
        /// Performs a connection to the remote server
        /// </summary>
        /// <param name="endPoint">Remote end point</param>
        public virtual void Connect(EndPoint endPoint)
        {
            fEndPoint = endPoint;
            fServerUri = new Uri(fProtocol + "://" + fEndPoint.ToString());
            Connect();
        }

        /// <summary>
        /// Performs a socket receive in a loop, will dispatch the events (all in the same thread)
        /// Note: this is blocking
        /// </summary>
        /// <param name="sleep">Time in ms between each receive, will put current thread to sleep</param>
        /// <param name="check">A flag to check whether it is needed to exit the receive loop or not</param>
        public void ReceiveLoop(int sleep, ref bool check)
        {
            while (check)
            {
                Receive();
                Thread.Sleep(sleep);
            }
        }
        #endregion

        #region Read/Write Header
        internal static void WriteLength(Stream stream, int value)
        {
            byte[] buffer = new byte[4];
            buffer[0] = (byte)(value >> 24);
            buffer[1] = (byte)(value >> 16);
            buffer[2] = (byte)(value >> 8);
            buffer[3] = (byte)value;
            stream.Write(buffer, 0, 4);
        }

        internal static void WriteKey(Stream stream, string value)
        {
            byte[] buffer = new byte[Packet.HeaderKeySize];
            for (int i = 0; i < Packet.HeaderKeySize * 2; i+=2)
                buffer[i / 2] = byte.Parse(value.Substring(i, 2), System.Globalization.NumberStyles.HexNumber);

            stream.Write(buffer, 0, Packet.HeaderKeySize);
        }

        internal static int ReadLength(Stream stream)
        {
            return stream.ReadByte() << 24
                 | (stream.ReadByte() << 16)
                 | (stream.ReadByte() << 8)
                 | (stream.ReadByte());
        }

        internal static string ReadKey(Stream stream)
        {
            char[] chars = new char[Packet.HeaderKeySize * 2];
            byte current;
            byte readByte;

            for (int y = 0, x = 0; y < Packet.HeaderKeySize; ++y, ++x)
            {
                readByte   = (byte)stream.ReadByte();
                current    = ((byte)(readByte >> 4));
                chars[x]   = (char)(current > 9 ? current + 0x37 : current + 0x30);
                current    = ((byte)(readByte & 0xF));
                chars[++x] = (char)(current > 9 ? current + 0x37 : current + 0x30);
            }

            return new string(chars);
        }
        #endregion

        #region Abstract Methods and Properties
        /// <summary>
        /// Connects to the server
        /// </summary>
        protected abstract void Connect();

        /// <summary>
        /// Disconnects from the server
        /// </summary>
        public abstract void Disconnect();

        /// <summary>
        /// Invokes an operation on the server
        /// </summary>
        /// <param name="operationKey">The identifier for the operation to invoke on the server</param>
        /// <param name="packet">The body packet, can be null depending on the protocol specification</param>
        public abstract void Send(string operationKey, IPacket packet);

        /// <summary>
        /// Gets a value that indicates whether the channel is connected
        /// to a remote host as of the last send/receive operation
        /// </summary>
        public abstract bool IsConnected { get; }

        /// <summary>
        /// Gets/Sets whether the send aggregation should be used
        /// One must explicitly call SendAllPending() to send data in aggregated mode
        /// </summary>
        public abstract bool UseCoalescing { get; set; }

        /// <summary>
        /// If the channel is in coalescing mode, this will send all pending packets to the server
        /// </summary>
        public abstract void SendAllPending();

        /// <summary>
        /// Performs a receive, will dispatch the events (all in the same thread)
        /// </summary>
        public abstract void Receive();

        /// <summary>
        /// Invokes OnReceive method
        /// </summary>
        internal abstract void OnReceive(ChannelReceiveEventArgs e);
        #endregion

        #region Public Events
        /// <summary>
        /// This event fires when a underlying communication layer is connected to the remote server
        /// </summary>
        public event EventHandler<ConnectionEventArgs> Connected;

        /// <summary>
        /// This event fires when a underlying communication layer is disconnected from the remote server
        /// </summary>
        public event EventHandler<ConnectionEventArgs> Disconnected;

        /// <summary>
        /// Triggers the Connected event.
        /// </summary>
        protected virtual void OnConnected()
        {
            // If already in that state, do nothing
            if (!fDisconnected)
                return;

            // Keep a flag saying that the socket is connected
            fDisconnected = false;

            // Check if we need to send an event
            if (Connected != null)
            {
                // this is required, since the application
                // logic may block in a tight loop, and
                // we don't want to block the IO threads
                
                Thread applicationWorker = new Thread(
                    new ThreadStart(delegate()
                    {
                        Connected(this, new ConnectionEventArgs());
                    }
                ));

                applicationWorker.Start();
            }
        }

        /// <summary>
        /// Triggers the Disconnected event.
        /// </summary>
        protected virtual void OnDisconnected()
        {
            // If already in that state, do nothing
            if (fDisconnected)
                return;

            // Keep a flag saying that the socket is disconnected
            fDisconnected = true;

            // Check if we need to send an event
            if (Disconnected != null)
            {
                Thread applicationWorker = new Thread(
                    new ThreadStart(delegate()
                    {
                        Disconnected(this, new ConnectionEventArgs());
                    }
                ));

                applicationWorker.Start();
            }
        }
        #endregion

        #region Private Methods

        private IPEndPoint ParseEndPoint(string host, int port)
        {
            IPAddress address;
            if (!IPAddress.TryParse(host, out address))
            {
                IPAddress[] addresses = Dns.GetHostAddresses(host);
                if (addresses.Length == 0)
                {
                    throw new ArgumentException(
                        "Unable to retrieve address from specified host name.",
                        "hostName"
                    );
                }
                address = addresses[0];
            }

            return new IPEndPoint(address, port);
        }
        #endregion

    }




    /// <summary>
    /// Represents a packet encoder that encodes/decodes packets accordingly to the Ray format.
    /// </summary>
    public class RayHttpEncoder : IPacketEncoder
    {
        /// <summary>
        /// Defines how the outgoing packet is encoded. This may modify packet.CompiledBuffer property in order
        /// to recompile the packet body.
        /// </summary>
        /// <param name="channel">The channel that sends the packet.</param>
        /// <param name="buffer">The data buffer to send.</param>
        /// <param name="length">The length of the data buffer to send.</param>
        public virtual void EncodeOutgoingPacket(ChannelBase channel, ref byte[] buffer, ref int length)
        {
            // Encode the body to Base64 String
            string utf8Payload = System.Convert.ToBase64String(buffer, 0, length);
            byte[] contentBuffer = Encoding.UTF8.GetBytes(utf8Payload);

            // Prepare HTTP Headers
            string endPoint = channel.EndPoint.ToString();
            StringBuilder headers = new StringBuilder();
            headers.Append("POST http://");
            headers.Append(endPoint);
            headers.Append(" HTTP/1.1");
            headers.Append("\r\nHost: ");
            headers.Append(endPoint);
            headers.Append("\r\nRay-Type: 1.0");
            headers.Append("\r\nContent-Length: ");
            headers.Append(contentBuffer.Length);
            headers.Append("\r\n\r\n");
            byte[] headersBuffer = Encoding.ASCII.GetBytes(headers.ToString());

            // Compile final buffer
            byte[] compiled = new byte[headersBuffer.Length + contentBuffer.Length];
            Buffer.BlockCopy(headersBuffer, 0, compiled, 0, headersBuffer.Length);
            Buffer.BlockCopy(contentBuffer, 0, compiled, headersBuffer.Length, contentBuffer.Length);

            // Return
            buffer = compiled;
            length = compiled.Length;
        }

        /// <summary>
        /// Defines how the incoming packet is decoded.
        /// </summary>
        /// <param name="channel">The channel that received the packet.</param>
        /// <param name="buffer">The received data buffer.</param>
        /// <param name="length">The length of the received data buffer.</param>
        public virtual void DecodeIncomingPacket(ChannelBase channel, ref byte[] buffer, ref int length)
        {
            // Skip the header until CRLF CRLF and decode the body
            using (MemoryStream stream = new MemoryStream())
            {
                int start = 0;
                int end = length;
                int idx = 0;
                int len = Math.Min(length, buffer.Length);
                while (idx < len - 4)
                {
                    if (buffer[idx] == 0x0D &&
                        buffer[idx + 1] == 0x0A &&
                        buffer[idx + 2] == 0x0D &&
                        buffer[idx + 3] == 0x0A)
                    {
                        start = idx + 4;
                    }

                    if (start > 0 &&
                        buffer[idx] == '/' &&
                        buffer[idx + 1] == '1' &&
                        buffer[idx + 2] == '.' &&
                        buffer[idx + 3] == '1')
                    {
                        // HTTP/1.1
                        end = idx - 4;

                        // Get Payload
                        string utf8Payload = Encoding.UTF8.GetString(buffer, start, end - start);
                        byte[] decoded = System.Convert.FromBase64String(utf8Payload);
                        stream.Write(decoded, 0, decoded.Length);

                        start = 0;
                        end = length;
                    }

                    idx++;
                }

                // Get Payload
                if (start > 0)
                {
                    string utf8PayloadLast = Encoding.UTF8.GetString(buffer, start, end - start);
                    byte[] decodedLast = System.Convert.FromBase64String(utf8PayloadLast);
                    stream.Write(decodedLast, 0, decodedLast.Length);
                }

                // Get the resut buffer
                buffer = stream.GetBuffer();
                length = (int)stream.Length;
            }
        }

    }




    public sealed class ConnectionEventArgs : EventArgs
    {
        public ConnectionEventArgs() : base() { }
    }




    public sealed class PacketReceiveEventArgs<T> : EventArgs
        where T : class, IPacket
    {
        public T Data;
        public PacketReceiveEventArgs(IPacket dataReceived) { Data = dataReceived as T; }
    }

    public class LatencyComputedEventArgs : EventArgs
    {
        public uint Latency = 0;
        public LatencyComputedEventArgs(uint Latency) { this.Latency = Latency; }
    }



    /// <summary>
    /// Represents event arguments for an event that is issued when a channel receives a packet.
    /// </summary>
    internal sealed class ChannelReceiveEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the packet received.
        /// </summary>
        internal object Packet;

        /// <summary>
        /// Gets the operation key for the received packet.
        /// </summary>
        internal string Operation;

        /// <summary>
        /// Gets or sets whether the packet was handled or not.
        /// </summary>
        internal bool Handled = false;

        /// <summary>
        /// Constructs a new instance of <see cref=">ChannelReceiveEventArgs"/> class.
        /// </summary>
        /// <param name="operation">The operation key for the packet.</param>
        /// <param name="packet">The packet value.</param>
        internal ChannelReceiveEventArgs(string operation, object packet) 
        { 
            this.Operation = operation; 
            this.Packet = packet; 
        }
    }




    public interface IEntity
    {
        void Read(PacketReader reader);
        void Write(PacketWriter writer);
    }





    public interface IPacket : IEntity
    {

    }

    /// <summary>
    /// Defines a contract for encoding/decoding packets.
    /// </summary>
    public interface IPacketEncoder
    {
        /// <summary>
        /// Defines how the outgoing packet is encoded. This may modify packet.CompiledBuffer property in order
        /// to recompile the packet body.
        /// </summary>
        /// <param name="channel">The channel that sends the packet.</param>
        /// <param name="buffer">The data buffer to send.</param>
        /// <param name="length">The length of the data buffer to send.</param>
        void EncodeOutgoingPacket(ChannelBase channel, ref byte[] buffer, ref int length);

        /// <summary>
        /// Defines how the incoming packet is decoded.
        /// </summary>
        /// <param name="channel">The channel that received the packet.</param>
        /// <param name="buffer">The received data buffer.</param>
        /// <param name="length">The length of the received data buffer.</param>
        void DecodeIncomingPacket(ChannelBase channel, ref byte[] buffer, ref int length);
    }


/*
 * Improved version to C# LibLZF Port:
 * Copyright (c) 2010 Roman Atachiants <kelindar@gmail.com>
 * 
 * Original CLZF Port:
 * Copyright (c) 2005 Oren J. Maurice <oymaurice@hazorea.org.il>
 * 
 * Original LibLZF Library & Algorithm:
 * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>
 * 
 * Redistribution and use in source and binary forms, with or without modifica-
 * tion, are permitted provided that the following conditions are met:
 * 
 *   1.  Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 * 
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 * 
 *   3.  The name of the author may not be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
 * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
 * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
 * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License version 2 (the "GPL"), in which case the
 * provisions of the GPL are applicable instead of the above. If you wish to
 * allow the use of your version of this file only under the terms of the
 * GPL and not to allow others to use your version of this file under the
 * BSD license, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the GPL. If
 * you do not delete the provisions above, a recipient may use your version
 * of this file under either the BSD or the GPL.
 */



    /// <summary>
    /// Improved C# LZF Compressor, a very small data compression library. The compression algorithm is extremely fast. 
    /// </summary>
    public sealed class LZF
    {
        public readonly static LZF Instance = new LZF();

        /// <summary>
        /// Hashtable, thac can be allocated only once
        /// </summary>
        private readonly long[] HashTable = new long[HSIZE];

        private const uint HLOG = 14;
        private const uint HSIZE = (1 << 14);
        private const uint MAX_LIT = (1 << 5);
        private const uint MAX_OFF = (1 << 13);
        private const uint MAX_REF = ((1 << 8) + (1 << 3));

        /// <summary>
        /// Compresses the data using LibLZF algorithm
        /// </summary>
        /// <param name="input">Reference to the data to compress</param>
        /// <param name="inputOffset">The offset in the input array where the compression should start</param>
        /// <param name="inputLength">Lenght of the data to compress</param>
        /// <param name="output">Reference to a buffer which will contain the compressed data</param>
        /// <returns>The size of the compressed archive in the output buffer</returns>
        public int Compress(byte[] input, int inputOffset, int inputLength, ref byte[] output)
        {
            Array.Clear(HashTable, 0, (int)HSIZE);

            inputLength = inputOffset + inputLength;
            int outputLength = output.Length;
            long hslot;
            uint iidx = (uint)inputOffset;
            uint oidx = 0;
            long reference;

            uint hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]); // FRST(in_data, iidx);
            long off;
            int lit = 0;

            for (; ; )
            {
                if (iidx < inputLength - 2)
                {
                    hval = (hval << 8) | input[iidx + 2];
                    hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));
                    reference = HashTable[hslot];
                    HashTable[hslot] = (long)iidx;


                    if ((off = iidx - reference - 1) < MAX_OFF
                        && iidx + 4 < inputLength
                        && reference > 0
                        && input[reference + 0] == input[iidx + 0]
                        && input[reference + 1] == input[iidx + 1]
                        && input[reference + 2] == input[iidx + 2]
                        )
                    {
                        /* match found at *reference++ */
                        uint len = 2;
                        uint maxlen = (uint)inputLength - iidx - len;
                        maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;

                        if (oidx + lit + 1 + 3 >= outputLength)
                            return 0;

                        do
                            len++;
                        while (len < maxlen && input[reference + len] == input[iidx + len]);

                        if (lit != 0)
                        {
                            output[oidx++] = (byte)(lit - 1);
                            lit = -lit;
                            do
                                output[oidx++] = input[iidx + lit];
                            while ((++lit) != 0);
                        }

                        len -= 2;
                        iidx++;

                        if (len < 7)
                        {
                            output[oidx++] = (byte)((off >> 8) + (len << 5));
                        }
                        else
                        {
                            output[oidx++] = (byte)((off >> 8) + (7 << 5));
                            output[oidx++] = (byte)(len - 7);
                        }

                        output[oidx++] = (byte)off;

                        iidx += len - 1;
                        hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);

                        hval = (hval << 8) | input[iidx + 2];
                        HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;
                        iidx++;

                        hval = (hval << 8) | input[iidx + 2];
                        HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;
                        iidx++;
                        continue;
                    }
                }
                else if (iidx == inputLength)
                    break;

                /* one more literal byte we must copy */
                lit++;
                iidx++;

                if (lit == MAX_LIT)
                {
                    if (oidx + 1 + MAX_LIT >= outputLength)
                        return 0;

                    output[oidx++] = (byte)(MAX_LIT - 1);
                    lit = -lit;
                    do
                        output[oidx++] = input[iidx + lit];
                    while ((++lit) != 0);
                }
            }

            if (lit != 0)
            {
                if (oidx + lit + 1 >= outputLength)
                    return 0;

                output[oidx++] = (byte)(lit - 1);
                lit = -lit;
                do
                    output[oidx++] = input[iidx + lit];
                while ((++lit) != 0);
            }

            return (int)oidx;
        }

        /// <summary>
        /// Compresses the data using LibLZF algorithm
        /// </summary>
        /// <param name="input">Reference to the data to compress</param>
        /// <param name="inputOffset">The offset in the input array where the compression should start</param>
        /// <param name="inputLength">Lenght of the data to compress</param>
        /// <param name="output">The stream where the compressor should compress to</param>
        /// <returns>The size of the compressed archive in the output buffer</returns>
        public int Compress(byte[] input, int inputOffset, int inputLength, MemoryStream output)
        {
            Array.Clear(HashTable, 0, (int)HSIZE);

            inputLength = inputOffset + inputLength;
            long hslot;
            uint iidx = (uint)inputOffset;
            uint oidx = 0;
            long reference;

            uint hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);
            long off;
            int lit = 0;

            for (; ; )
            {
                if (iidx < inputLength - 2)
                {
                    hval = (hval << 8) | input[iidx + 2];
                    hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));
                    reference = HashTable[hslot];
                    HashTable[hslot] = (long)iidx;


                    if ((off = iidx - reference - 1) < MAX_OFF
                        && iidx + 4 < inputLength
                        && reference > 0
                        && input[reference + 0] == input[iidx + 0]
                        && input[reference + 1] == input[iidx + 1]
                        && input[reference + 2] == input[iidx + 2]
                        )
                    {
                        /* match found at *reference++ */
                        uint len = 2;
                        uint maxlen = (uint)inputLength - iidx - len;
                        maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;

                        do
                            len++;
                        while (len < maxlen && input[reference + len] == input[iidx + len]);

                        if (lit != 0)
                        {
                            oidx++;
                            output.WriteByte((byte)(lit - 1));
                            lit = -lit;
                            do
                            {
                                oidx++;
                                output.WriteByte(input[iidx + lit]);
                            }
                            while ((++lit) != 0);
                        }

                        len -= 2;
                        iidx++;

                        if (len < 7)
                        {
                            oidx++;
                            output.WriteByte((byte)((off >> 8) + (len << 5)));
                        }
                        else
                        {
                            oidx++;
                            oidx++;
                            output.WriteByte((byte)((off >> 8) + (7 << 5)));
                            output.WriteByte((byte)(len - 7));
                        }

                        oidx++;
                        output.WriteByte((byte)off);

                        iidx += len - 1;
                        hval = (uint)(((input[iidx]) << 8) | input[iidx + 1]);

                        hval = (hval << 8) | input[iidx + 2];
                        HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;
                        iidx++;

                        hval = (hval << 8) | input[iidx + 2];
                        HashTable[((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;
                        iidx++;
                        continue;
                    }
                }
                else if (iidx == inputLength)
                    break;

                /* one more literal byte we must copy */
                lit++;
                iidx++;

                if (lit == MAX_LIT)
                {
                    oidx++;
                    output.WriteByte((byte)(MAX_LIT - 1));
                    lit = -lit;
                    do
                    {
                        oidx++;
                        output.WriteByte(input[iidx + lit]);
                    }
                    while ((++lit) != 0);
                }
            }

            if (lit != 0)
            {
                oidx++;
                output.WriteByte((byte)(lit - 1));
                lit = -lit;
                do
                {
                    oidx++;
                    output.WriteByte(input[iidx + lit]);
                }
                while ((++lit) != 0);
            }

            return (int)oidx;
        }

        /// <summary>
        /// Decompresses the data using LibLZF algorithm
        /// </summary>
        /// <param name="input">Reference to the data to decompress</param>
        /// <param name="inputOffset">Offset in the input array where the decompression should begin</param>
        /// <param name="inputLength">Lenght of the data to decompress</param>
        /// <param name="output">Reference to a buffer which will contain the decompressed data</param>
        /// <returns>Returns decompressed size</returns>
        public int Decompress(byte[] input, int inputOffset, int inputLength, ref byte[] output)
        {
            inputLength = inputOffset + inputLength;

            int outputLength = output.Length;
            uint iidx = (uint)inputOffset;
            uint oidx = 0;

            do
            {
                uint ctrl = input[iidx++];

                if (ctrl < (1 << 5)) /* literal run */
                {
                    ctrl++;

                    if (oidx + ctrl > outputLength)
                    {
                        // Promote the buffer
                        outputLength = (int)(oidx + ctrl) * 2;
                        Array.Resize<byte>(ref output, outputLength);
                    }

                    do
                        output[oidx++] = input[iidx++];
                    while ((--ctrl) != 0);
                }
                else /* back reference */
                {
                    uint len = ctrl >> 5;

                    int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);

                    if (len == 7)
                        len += input[iidx++];

                    reference -= input[iidx++];

                    if (oidx + len + 2 > outputLength)
                    {
                        // Promote the buffer
                        outputLength = (int)(oidx + len + 2) * 2;
                        Array.Resize<byte>(ref output, outputLength);
                    }

                    if (reference < 0)
                    {
                        //SET_ERRNO (EINVAL);
                        return 0;
                    }

                    output[oidx++] = output[reference++];
                    output[oidx++] = output[reference++];

                    do
                        output[oidx++] = output[reference++];
                    while ((--len) != 0);
                }
            }
            while (iidx < inputLength);

            return (int)oidx;
        }

        /// <summary>
        /// Decompresses the data using LibLZF algorithm
        /// </summary>
        /// <param name="input">Reference to the data to decompress</param>
        /// <param name="inputOffset">Offset in the input array where the decompression should begin</param>
        /// <param name="inputLength">Lenght of the data to decompress</param>
        /// <param name="output">The stream to decompress to</param>
        /// <returns>Returns decompressed size</returns>
        public int Decompress(byte[] input, int inputOffset, int inputLength, MemoryStream output)
        {
            inputLength = inputOffset + inputLength;

            uint iidx = (uint)inputOffset;
            uint oidx = 0;

            do
            {
                uint ctrl = input[iidx++];

                if (ctrl < (1 << 5)) /* literal run */
                {
                    ctrl++;

                    do
                    {
                        oidx++;
                        output.WriteByte(input[iidx++]);
                    }
                    while ((--ctrl) != 0);
                }
                else /* back reference */
                {
                    uint len = ctrl >> 5;

                    int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);

                    if (len == 7)
                        len += input[iidx++];

                    reference -= input[iidx++];

                    if (reference < 0)
                    {
                        //SET_ERRNO (EINVAL);
                        return 0;
                    }

                    byte[] buffer = output.GetBuffer();
                    byte b1 = buffer[reference++];
                    output.WriteByte(b1);
                    oidx++;

                    byte b2 = buffer[reference++];
                    output.WriteByte(b2);
                    oidx++;

                    do
                    {
                        buffer = output.GetBuffer();
                        output.WriteByte(buffer[reference++]);
                        oidx++;
                    }
                    while ((--len) != 0);
                }
            }
            while (iidx < inputLength);

            return (int)oidx;
        }
    }





    internal abstract class OperationReaderBase 
    {
        internal static OperationReaderBase Instance;

        internal static void SetInstance(OperationReaderBase instance)
        {
            Instance = instance;
        }

        /// <summary>
        /// Reads an operation and returns the object it read
        /// </summary>
        internal abstract object Read(string operationKey, PacketReader reader);


    }





    public class Packet
    {
        /// <summary>
        /// Total size of the header for each packet
        /// </summary>
        internal const int HeaderSize = HeaderLengthSize + HeaderKeySize;

        /// <summary>
        /// Size of the header bytes that determine Lenght of the packet
        /// </summary>
        internal const int HeaderLengthSize = 4;

        /// <summary>
        /// Size of the header data to add to the message length
        /// </summary>
        internal const int HeaderKeySize = 4;


        private string fOperation = "00000000";

        /// <summary>
        /// Gets or sets the operation identifier.
        /// </summary>
        public string Operation
        {
            get { return fOperation; }
            set { fOperation = value; }
        }

        /// <summary>
        /// Constructs a new instance of <see cref="Packet"/> class for the provided operation.
        /// </summary>
        /// <param name="operationKey">The operation identifier to bind the packet to.</param>
        public Packet(string operationKey)
        {
            fOperation = operationKey;
        }

    }




    public class PacketReader
    {
        #region Ctor & Properties
        // Static encoding (perf tweak)
        private static Encoding UTF8 = Encoding.UTF8;
        private static BufferPool Buffers = new BufferPool(2, 4 * 1024 * 1024);

        // Binary data
        private byte[] Data;
        private int Size;
        private int Index;
        private int BufferHandle = -1;

        public PacketReader(int size)
        {
            if (BufferHandle > 0)
                Buffers.Release(BufferHandle);
            BufferHandle = Buffers.Acquire(out Data, size);
            Size = size;
            Index = 0;
        }

        public byte[] Reset(int size)
        {
            if (BufferHandle > 0)
                Buffers.Release(BufferHandle);
            BufferHandle = Buffers.Acquire(out Data, size);
            Size = size;
            Index = 0;
            return Data;
        }

        public void Release()
        {
            if (BufferHandle > 0)
                Buffers.Release(BufferHandle);
            BufferHandle = -1;
            Size = 0;
            Index = 0;
        }

        #endregion

        #region Reading Methods

        public int Seek(int offset, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.Begin: Index = offset; break;
                case SeekOrigin.Current: Index += offset; break;
                case SeekOrigin.End: Index = Size - offset; break;
            }

            return Index;
        }

        public long ReadInt64()
        {
            if ((Index + 8) > Size)
                return 0;

            long value = Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];

            return value;
        }


        public ulong ReadUInt64()
        {
            if ((Index + 8) > Size)
                return 0;

            ulong value = Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];
            value <<= 8;
            value |= Data[Index++];

            return value;
        }


        public int ReadInt32()
        {
            if ((Index + 4) > Size)
                return 0;

            return Data[Index++] << 24
                 | (Data[Index++] << 16)
                 | (Data[Index++] << 8)
                 | (Data[Index++]);

        }

        public short ReadInt16()
        {
            if ((Index + 2) > Size)
                return 0;

            return (short)((Data[Index++] << 8) | Data[Index++]);
        }

        public byte ReadByte()
        {
            if ((Index + 1) > Size)
                return 0;

            return Data[Index++];
        }

        public uint ReadUInt32()
        {
            if ((Index + 4) > Size)
                return 0;

            return (uint)((Data[Index++] << 24) | (Data[Index++] << 16) | (Data[Index++] << 8) | Data[Index++]);
        }

        public ushort ReadUInt16()
        {
            if ((Index + 2) > Size)
                return 0;

            return (ushort)((Data[Index++] << 8) | Data[Index++]);
        }

        public sbyte ReadSByte()
        {
            if ((Index + 1) > Size)
                return 0;

            return (sbyte)Data[Index++];
        }

        public bool ReadBoolean()
        {
            if ((Index + 1) > Size)
                return false;

            return (Data[Index++] != 0);
        }

        public string ReadString()
        {
            int length = ReadInt32();
            if (length == 0)
                return String.Empty;
            string result = UTF8.GetString(Data, Index, length);
            Index += length;
            return result;
        }

        public DateTime ReadDateTime()
        {
            short year = ReadInt16();
            short month = ReadInt16();
            short day = ReadInt16();
            short hour = ReadInt16();
            short minute = ReadInt16();
            short second = ReadInt16();
            short millisecond = ReadInt16();

            return new DateTime(year, month, day, hour, minute, second, millisecond);
            //return new DateTime(long.Parse(ReadString()));
        }


        /// <summary>
        /// Reads an IEEE 754 double-precision (64-bit) floating-point number from the buffer
        /// </summary>
        public double ReadDouble()
        {
            return BitConverter.Int64BitsToDouble(ReadInt64());
        }

        /// <summary>
        /// Reads an IEEE 754 single-precision (32-bit) floating-point number from the buffer
        /// </summary>
        public float ReadSingle()
        {
            var value = BitConverter.ToSingle(Data, Index);
            Index += 4;
            return value;
        }


        /// <summary>
        /// Reads a list of packets
        /// </summary>
        public void ReadEntity(IEntity entity)
        {
            entity.Read(this);
        }

        /// <summary>
        /// Reads a byte array 
        /// </summary>
        public byte[] ReadByteArray()
        {
            int length = ReadInt32();
            byte[] result = new byte[length];
            Buffer.BlockCopy(Data, Index, result, 0, length);
            Index += length;
            return result;
        }

        /// <summary>
        /// Reads a dynamic value (of the supported types)
        /// </summary>
        public Object ReadDynamic()
        {
            if (ReadByte() == 1)
            {
                string stringType = "System." + ReadString();
                Type type = Type.GetType(stringType);
                switch (SupportedTypes.Map[type])
                {
                    case 0: return ReadByte();
                    case 1: return ReadInt16();
                    case 2: return ReadInt32();
                    case 3: return ReadInt64();
                    case 4: return ReadUInt16();
                    case 5: return ReadUInt32();
                    case 6: return ReadUInt64();
                    case 7: return ReadBoolean();
                    case 8: return ReadSingle();
                    case 9: return ReadDouble();
                    case 10: return ReadDateTime();
                    case 11: return ReadString();
                    default: return null;
                }
            }
            return null;
        }


        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<bool> ReadListOfBoolean()
        {
            int length = ReadInt32();
            List<bool> result = new List<bool>();
            for (int i = 0; i < length; ++i)
                result.Add((bool)ReadBoolean());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<byte> ReadListOfByte()
        {
            int length = ReadInt32();
            List<byte> result = new List<byte>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadByte());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<sbyte> ReadListOfSByte()
        {
            int length = ReadInt32();
            List<sbyte> result = new List<sbyte>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadSByte());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<short> ReadListOfInt16()
        {
            int length = ReadInt32();
            List<short> result = new List<short>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadInt16());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<ushort> ReadListOfUInt16()
        {
            int length = ReadInt32();
            List<ushort> result = new List<ushort>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadUInt16());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<int> ReadListOfInt32()
        {
            int length = ReadInt32();
            List<int> result = new List<int>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadInt32());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<uint> ReadListOfUInt32()
        {
            int length = ReadInt32();
            List<uint> result = new List<uint>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadUInt32());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<double> ReadListOfDouble()
        {
            int length = ReadInt32();
            List<double> result = new List<double>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadDouble());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<float> ReadListOfSingle()
        {
            int length = ReadInt32();
            List<float> result = new List<float>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadSingle());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<DateTime> ReadListOfDateTime()
        {
            int length = ReadInt32();
            List<DateTime> result = new List<DateTime>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadDateTime());
            return result;
        }

        /// <summary>
        /// Reads a list 
        /// </summary>
        public List<string> ReadListOfString()
        {
            int length = ReadInt32();
            List<string> result = new List<string>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadString());
            return result;
        }

        /// <summary>
        /// Reads a list of packets
        /// </summary>
        public List<TEntity> ReadListOfEntity<TEntity>()
            where TEntity : IEntity, new()
        {
            int length = ReadInt32();
            List<TEntity> result = new List<TEntity>();

            for (int i = 0; i < length; ++i)
            {

                try
                {
                    TEntity packet = new TEntity();
                    packet.Read(this);

                    result.Add(packet);
                }
                catch(Exception ex)
                {
                    Console.WriteLine(ex);
                }
            }
            return result;
        }

        /// <summary>
        /// Reads a list of dynamic members
        /// </summary>
        public List<object> ReadListOfDynamic()
        {
            int length = ReadInt32();
            List<object> result = new List<object>();
            for (int i = 0; i < length; ++i)
                result.Add(ReadDynamic());
            return result;
        }

        #endregion

        #region Trace

        public static void FormatBuffer(TextWriter output, Stream input, int length)
        {
            output.WriteLine("        0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F");
            output.WriteLine("       -- -- -- -- -- -- -- --  -- -- -- -- -- -- -- --");

            int byteIndex = 0;

            int whole = length >> 4;
            int rem = length & 0xF;

            for (int i = 0; i < whole; ++i, byteIndex += 16)
            {
                StringBuilder bytes = new StringBuilder(49);
                StringBuilder chars = new StringBuilder(16);

                for (int j = 0; j < 16; ++j)
                {
                    int c = input.ReadByte();

                    bytes.Append(c.ToString("X2"));

                    if (j != 7)
                    {
                        bytes.Append(' ');
                    }
                    else
                    {
                        bytes.Append("  ");
                    }

                    if (c >= 0x20 && c < 0x80)
                    {
                        chars.Append((char)c);
                    }
                    else
                    {
                        chars.Append('.');
                    }
                }

                output.Write(byteIndex.ToString("X4"));
                output.Write("   ");
                output.Write(bytes.ToString());
                output.Write("  ");
                output.WriteLine(chars.ToString());
            }

            if (rem != 0)
            {
                StringBuilder bytes = new StringBuilder(49);
                StringBuilder chars = new StringBuilder(rem);

                for (int j = 0; j < 16; ++j)
                {
                    if (j < rem)
                    {
                        int c = input.ReadByte();

                        bytes.Append(c.ToString("X2"));

                        if (j != 7)
                        {
                            bytes.Append(' ');
                        }
                        else
                        {
                            bytes.Append("  ");
                        }

                        if (c >= 0x20 && c < 0x80)
                        {
                            chars.Append((char)c);
                        }
                        else
                        {
                            chars.Append('.');
                        }
                    }
                    else
                    {
                        bytes.Append("   ");
                    }
                }

                output.Write(byteIndex.ToString("X4"));
                output.Write("   ");
                output.Write(bytes.ToString());
                output.Write("  ");
                output.WriteLine(chars.ToString());
            }
        }

        #endregion

        #region Compression
        public int Decompress()
        {
            lock (LZF.Instance)
            {
                byte[] pooledBuffer;
                int handle = Buffers.Acquire(out pooledBuffer);
                byte[] outBuffer = pooledBuffer;
                int decompressedSize = LZF.Instance.Decompress(Data, 0, Size, ref outBuffer);

                // Release the actual reader's buffer 
                Buffers.Release(BufferHandle);
                BufferHandle = -1;
                Data = outBuffer;
                Size = decompressedSize;
                Index = 0;

                // Release the buffer if a new one was created meanwhile
                if (outBuffer != pooledBuffer)
                    Buffers.Release(handle);
                else
                { // Replace BufferHandle by a new one
                    BufferHandle = handle;
                }

                return decompressedSize;
            }
        }
        #endregion

    }



	/// <summary>
	/// Provides functionality for writing primitive binary data.
	/// </summary>
	public class PacketWriter
	{
        private static BufferPool Buffers = new BufferPool(2, 4 * 1024 * 1024);

        /// <summary>
        /// Instantiates a new PacketWriter instance with a given capacity.
        /// </summary>
        public PacketWriter()
        {
            fStream = new MemoryStream();
        }

        #region Properties

        /// <summary>
		/// Internal stream which holds the entire packet.
		/// </summary>
		private MemoryStream fStream;

		/// <summary>
		/// Internal format buffer.
		/// </summary>
		private byte[] m_Buffer = new byte[32];

        /// <summary>
        /// Gets the total stream length.
        /// </summary>
        public long Length
        {
            get { return fStream.Length; }
        }

        /// <summary>
        /// Gets or sets the current stream position.
        /// </summary>
        public long Position
        {
            get { return fStream.Position; }
            set { fStream.Position = value; }
        }

        /// <summary>
        /// The internal stream used by this PacketWriter instance.
        /// </summary>
        public MemoryStream UnderlyingStream
        {
            get { return fStream; }
            set { fStream = value; }
        }

        /// <summary>
        /// Offsets the current position from an origin.
        /// </summary>
        public long Seek(long offset, SeekOrigin origin)
        {
            return fStream.Seek(offset, origin);
        }

        /// <summary>
        /// Gets the entire stream content as a byte array.
        /// </summary>
        public byte[] ToArray()
        {
            return fStream.ToArray();
        }

        #endregion

        #region Write Primitives
        /// <summary>
		/// Writes a 1-byte boolean value to the underlying stream. False is represented by 0, true by 1.
		/// </summary>
		public void Write( bool value )
		{
			fStream.WriteByte( (byte)(value ? 1 : 0) );
		}

		/// <summary>
		/// Writes a 1-byte unsigned integer value to the underlying stream.
		/// </summary>
		public void Write( byte value )
		{
			fStream.WriteByte( value );
		}

		/// <summary>
		/// Writes a 1-byte signed integer value to the underlying stream.
		/// </summary>
		public void Write( sbyte value )
		{
			fStream.WriteByte( (byte) value );
		}

		/// <summary>
		/// Writes a 2-byte signed integer value to the underlying stream.
		/// </summary>
		public void Write( short value )
		{
			m_Buffer[0] = (byte)(value >> 8);
			m_Buffer[1] = (byte) value;

			fStream.Write( m_Buffer, 0, 2 );
		}

		/// <summary>
		/// Writes a 2-byte unsigned integer value to the underlying stream.
		/// </summary>
		public void Write( ushort value )
		{
			m_Buffer[0] = (byte)(value >> 8);
			m_Buffer[1] = (byte) value;

			fStream.Write( m_Buffer, 0, 2 );
		}

		/// <summary>
		/// Writes a 4-byte signed integer value to the underlying stream.
		/// </summary>
		public void Write( int value )
		{
			m_Buffer[0] = (byte)(value >> 24);
			m_Buffer[1] = (byte)(value >> 16);
			m_Buffer[2] = (byte)(value >>  8);
			m_Buffer[3] = (byte) value;

			fStream.Write( m_Buffer, 0, 4 );
		}

		/// <summary>
		/// Writes a 4-byte unsigned integer value to the underlying stream.
		/// </summary>
		public void Write( uint value )
		{
			m_Buffer[0] = (byte)(value >> 24);
			m_Buffer[1] = (byte)(value >> 16);
			m_Buffer[2] = (byte)(value >>  8);
			m_Buffer[3] = (byte) value;

			fStream.Write( m_Buffer, 0, 4 );
		}

        /// <summary>
        /// Writes a 8-byte signed integer value to the underlying stream.
        /// </summary>
        public void Write(long value)
        {
            m_Buffer[0] = (byte)(value >> 56);
            m_Buffer[1] = (byte)(value >> 48);
            m_Buffer[2] = (byte)(value >> 40);
            m_Buffer[3] = (byte)(value >> 32);
            m_Buffer[4] = (byte)(value >> 24);
            m_Buffer[5] = (byte)(value >> 16);
            m_Buffer[6] = (byte)(value >> 8);
            m_Buffer[7] = (byte)value;

            fStream.Write(m_Buffer, 0, 8);
        }

        /// <summary>
        /// Writes a 8-byte unsigned integer value to the underlying stream.
        /// </summary>
        public void Write(ulong value)
        {
            m_Buffer[0] = (byte)(value >> 56);
            m_Buffer[1] = (byte)(value >> 48);
            m_Buffer[2] = (byte)(value >> 40);
            m_Buffer[3] = (byte)(value >> 32);
            m_Buffer[4] = (byte)(value >> 24);
            m_Buffer[5] = (byte)(value >> 16);
            m_Buffer[6] = (byte)(value >> 8);
            m_Buffer[7] = (byte)value;

            fStream.Write(m_Buffer, 0, 8);
        }

        /// <summary>
        /// Writes a DateTime to a sequence of bytes to the underlying stream
        /// </summary>
        public void Write(DateTime value)
        {
            Write((short)value.Year);
            Write((short)value.Month);
            Write((short)value.Day);
            Write((short)value.Hour);
            Write((short)value.Minute);
            Write((short)value.Second);
            Write((short)value.Millisecond);
        }

        /// <summary>
        /// Writes an IEEE 754 double-precision (64-bit) floating-point number to the buffer
        /// </summary>
        public void Write(double value)
        {
            Write(BitConverter.DoubleToInt64Bits(value));
        }

        /// <summary>
        /// Writes an IEEE 754 single-precision (32-bit) floating-point number to the buffer
        /// </summary>
        public void Write(float value)
        {
            Write(BitConverter.GetBytes(value), 0, 4);
        }


		/// <summary>
		/// Writes a sequence of bytes to the underlying stream
		/// </summary>
		public void Write( byte[] buffer, int offset, int size )
		{
			fStream.Write( buffer, offset, size );
		}


		/// <summary>
		/// Writes a fixed-length big-endian unicode string value to the underlying stream. To fit (size), the string content is either truncated or padded with null characters.
		/// </summary>
		public void Write( string value )
		{
            if (String.IsNullOrEmpty(value))
            {
                Write((int)0);
            }
            else
            {
                byte[] stringBuffer = Encoding.UTF8.GetBytes(value);
                int size = stringBuffer.Length;

                Write(size);
                if (size > 0)
                {
                    fStream.SetLength(fStream.Length + size);
                    Write(stringBuffer, 0, size);
                }
            }
		}

        /// <summary>
        /// Writes a IPartialEntity in the packet
        /// </summary>
        public void Write(IEntity item)
        {
            item.Write(this);
        }

        /// <summary>
        /// Writes a byte array
        /// </summary>
        public void Write(byte[] array)
        {
            Write((int)array.Length);
            fStream.Write(array, 0, array.Length);
        }

        /// <summary>
        /// Writes a dynamic value (of the supported types)
        /// </summary>
        public void WriteDynamic(Object value)
        {
            Type type = value.GetType();
            string typeName = type.Name.ToString();
            switch (SupportedTypes.Map[type])
            {
                case 0:
                    Write((byte)1);
                    Write(typeName);
                    Write((byte)value);
                    break;
                case 1:
                    Write((byte)1);
                    Write(typeName);
                    Write((Int16)value);
                    break;
                case 2:
                    Write((byte)1);
                    Write(typeName);
                    Write((Int32)value);
                    break;
                case 3:
                    Write((byte)1);
                    Write(typeName);
                    Write((Int64)value);
                    break;
                case 4:
                    Write((byte)1);
                    Write(typeName);
                    Write((UInt16)value);
                    break;
                case 5:
                    Write((byte)1);
                    Write(typeName);
                    Write((UInt32)value);
                    break;
                case 6:
                    Write((byte)1);
                    Write(typeName);
                    Write((UInt64)value);
                    break;
                case 7:
                    Write((byte)1);
                    Write(typeName);
                    Write((Boolean)value);
                    break;
                case 8:
                    Write((byte)1);
                    Write(typeName);
                    Write((Single)value);
                    break;
                case 9:
                    Write((byte)1);
                    Write(typeName);
                    Write((Double)value);
                    break;
                case 10:
                    Write((byte)1);
                    Write(typeName);
                    Write((DateTime)value);
                    break;
                case 11:
                    Write((byte)1);
                    Write(typeName);
                    Write((String)value);
                    break;
                default:
                    // Not supported
                    Write((byte)0);
                    return;
            }
        }

        #endregion

        #region Write ILists
        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<Boolean> list)
        {
            Write((int)list.Count);
            foreach (bool item in list) Write(item);
        }

        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<Double> list)
        {
            Write((int)list.Count);
            foreach (double item in list) Write(item);
        }

        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<Single> list)
        {
            Write((int)list.Count);
            foreach (float item in list) Write(item);
        }

        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<byte> list)
        {
            Write((int)list.Count);
            foreach (byte item in list) Write(item);
        }


        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<sbyte> list)
        {
            Write((int)list.Count);
            foreach (sbyte item in list) Write(item);
        }


        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<short> list)
        {
            Write((int)list.Count);
            foreach (short item in list) Write(item);
        }


        /// <summary>
        /// Writes a list 
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<ushort> list)
        {
            Write((int)list.Count);
            foreach (ushort item in list) Write(item);
        }

        /// <summary>
        /// Writes a list
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<int> list)
        {
            Write((int)list.Count);
            foreach (int item in list) Write(item);
        }

        /// <summary>
        /// Writes a list
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<uint> list)
        {
            Write((int)list.Count);
            foreach (uint item in list) Write(item);
        }

        /// <summary>
        /// Writes a list
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<DateTime> list)
        {
            Write((int)list.Count);
            foreach (DateTime item in list) Write(item);
        }

        /// <summary>
        /// Writes a list
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<string> list)
        {
            Write((int)list.Count);
            foreach (string item in list) Write(item);
        }

        /// <summary>
        /// Writes a list of packets
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write(IList<IEntity> list)
        {
            Write((int)list.Count);
            foreach (IEntity item in list) item.Write(this);
        }

        /// <summary>
        /// Writes a list of packets
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void Write<TEntity>(IList<TEntity> list)
            where TEntity : IEntity
        {
            Write((int)list.Count);
            foreach (IEntity item in list) item.Write(this);
        }

        /// <summary>
        /// Writes a list of dynamic members
        /// </summary>
        /// <typeparam name="TList">The type of the list to write, should derive from IList generic</typeparam>
        /// <param name="list">The list instance to write</param>
        public void WriteDynamic(IList<object> list)
        {
            if (list == null)
            {
                Write((int)0);
                return;
            }
            Write((int)list.Count);
            for (int i = 0; i < list.Count; ++i)
                WriteDynamic(list[i]);
        }
        #endregion

        #region Compression
        public int Compress()
        {
            lock (LZF.Instance)
            {
                MemoryStream compressed = new MemoryStream();
                int length =  LZF.Instance.Compress(fStream.GetBuffer(), 0, (int)fStream.Length, compressed);
                fStream.Dispose();
                fStream = compressed;
                return length;
            }

        }
        #endregion
	}



    internal static class SupportedTypes
    {
        internal static Dictionary<Type, int> Map;
        static SupportedTypes()
        {
            Map = new Dictionary<Type, int>();
            Map.Add(typeof(Byte),0);
            Map.Add(typeof(Int16),1);
            Map.Add(typeof(Int32),2);
            Map.Add(typeof(Int64),3);
            Map.Add(typeof(UInt16),4);
            Map.Add(typeof(UInt32),5);
            Map.Add(typeof(UInt64),6);
            Map.Add(typeof(Boolean),7);
            Map.Add(typeof(Single),8);
            Map.Add(typeof(Double),9);
            Map.Add(typeof(DateTime),10);
            Map.Add(typeof(String),11);
        }
    }




    /// <summary>
    /// Represents a TCP/IP network channel.
    /// </summary>
    public abstract class TcpChannelBase : ChannelBase, IDisposable
    {
        private TcpSocket fSocket;
        private RayHttpEncoder fRay;
        private bool fUseRayTunneling = false;

        /// <summary>
        /// Constructs a TCP/IP network channel.
        /// </summary>
        public TcpChannelBase() : base("tcp")
        {
            fSocket = new TcpSocket(this);
            fRay = new RayHttpEncoder();
        }

        /// <summary>
        /// Connects to the server
        /// </summary>
        protected override void Connect()
        {
            if (this.IsConnected)
                throw new InvalidOperationException("Unable to connect as the socket is currently connected. Please disconnect first.");

            // Create a new socket
            fSocket = new TcpSocket(this);

            // Attempt to connect.
            fSocket.Connect(fEndPoint);

            // Setup ray tunneling if necessary.
            if (this.UseRayTunneling)
                IssueRayConnect();

            // If no exception was thrown, we should issue the connect event
            this.OnConnected();
        }

        /// <summary>
        /// Disconnects from the server
        /// </summary>
        public override void Disconnect()
        {
            if (this.IsConnected)
            {
                try
                {
                    // Attempt to disconnect.
                    fSocket.Disconnect(true);
                }
                finally
                {
                    // Always send the disconnected event after the call
                    this.OnDisconnected();
                }
            }
        }

        /// <summary>
        /// Invokes an operation on the server
        /// </summary>
        /// <param name="operationKey">The identifier for the operation to invoke on the server</param>
        /// <param name="packet">The body packet, can be null depending on the protocol specification</param>
        public override void Send(string operationKey, IPacket packet)
        {
            try
            {
                // Forward
                PacketWriter writer = new PacketWriter();
                if (packet != null)
                    writer.Write(packet);
                fSocket.Send(operationKey, writer);
            }
            catch (Exception ex)
            {
                // Check for disconnected state
                if (!this.IsConnected)
                    this.OnDisconnected();

                // Rethrow
                throw ex;
            }
        }

        /// <summary>
        /// Gets/Sets whether the send aggregation should be used
        /// One must explicitly call SendAllPending() to send data in aggregated mode
        /// </summary>
        public override bool UseCoalescing
        {
            get { return fSocket.UseCoalescing; }
            set { fSocket.UseCoalescing = value; }
        }

        /// <summary>
        /// Gets/Sets whether this tcp connection should be tunneled through Spike Ray.
        /// </summary>
        public bool UseRayTunneling
        {
            get { return fUseRayTunneling; }
            set 
            {
                if (fUseRayTunneling == value)
                    return;

                fUseRayTunneling = value;
                this.PacketEncoder = value ? fRay : null;
                if(value && this.IsConnected)
                    IssueRayConnect();
            }
        }

        /// <summary>
        /// Gets a value that indicates whether the channel is connected
        /// to a remote host as of the last send/receive operation.
        /// </summary>
        public override bool IsConnected
        {
            get { return fSocket == null ? false : fSocket.Connected && fSocket.IsConnected; }
        }

        /// <summary>
        /// If the channel is in aggregated mode, this will send all pending packets to the server
        /// </summary>
        public override void SendAllPending()
        {
            try
            {
                // Forward
                if (fSocket.UseCoalescing && fSocket.Connected)
                    fSocket.SendAllPending();
            }
            catch (Exception ex)
            {
                // Check for disconnected state
                if (!this.IsConnected)
                    this.OnDisconnected();

                // Rethrow
                throw ex;
            }
        }

        /// <summary>
        /// Performs a socket receive, will dispatch the events (all in the same thread)
        /// </summary>
        public override void Receive()
        {
            try
            {
                // Forward
                fSocket.Receive();
            }
            catch (Exception ex)
            {
                // Rethrow
                throw ex;
            }
            finally
            {
                // Check for disconnected state
                if (!this.IsConnected)
                    this.OnDisconnected();
            }
        }

        #region IDisposable Members

        public void Dispose()
        {
            try
            {
                if (fSocket != null && fSocket.Connected)
                    fSocket.Disconnect(false);
            }
            catch (Exception)
            {
                // We can not throw in dispose.
            }
        }

        #endregion

        #region Ray Members

        /// <summary>
        /// Issues Spike Ray HTTP CONNECT in order to establish an http tunnel.
        /// </summary>
        private void IssueRayConnect()
        {
            if (!this.IsConnected)
                return;

            StringBuilder packet = new StringBuilder();
            packet.Append("CONNECT http://");
            packet.Append(fEndPoint.ToString());
            packet.Append(" HTTP/1.1");
            packet.Append("\r\nHost: ");
            packet.Append(fEndPoint.ToString());
            packet.Append("\r\nConnection: keep-alive");
            packet.Append("\r\nProxy-Connection: keep-alive");
            packet.Append("\r\nRay-Type: 1.0");
            packet.Append("\r\nContent-Length: 0");
            packet.Append("\r\n\r\n");

            try
            {
                // Send it through the socket now
                fSocket.Send(Encoding.ASCII.GetBytes(packet.ToString()));
            }
            catch (Exception ex)
            {
                // Check for disconnected state
                if (!this.IsConnected)
                    this.OnDisconnected();

                // Rethrow
                throw ex;
            }
        }

        #endregion
    }




    internal sealed class TcpSocket : Socket
    {
        private TcpChannelBase fChannel;
        private PacketReader fReader = new PacketReader(1024);
        private MemoryStream fCoalesceStream = null;
        private byte[] fBuffer = new byte[0];
        private bool fPartialRecord = false;
        internal bool UseCoalescing;

        internal TcpSocket(TcpChannelBase channel)
            : base(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
        {
            fChannel = channel;
        }

        internal void Send(string operationKey, PacketWriter writer)
        {
            try
            {
                // Writes the length of the packet, the operation and the data
                int streamLength = (int)writer.Length + Packet.HeaderSize;
                using (MemoryStream stream = new MemoryStream(streamLength))
                {
                    // Write the operation number
                    int length = (int)writer.Length + Packet.HeaderKeySize;
                    ChannelBase.WriteLength(stream, length);

                    // Write the operation number
                    ChannelBase.WriteKey(stream, operationKey);

                    // Write the packet data
                    if (writer.Length > 0)
                        stream.Write(writer.UnderlyingStream.GetBuffer(), 0, (int)writer.Length);

                    // Send to the server
                    if (UseCoalescing)
                    {
                        if (fCoalesceStream == null) fCoalesceStream = new MemoryStream();
                        int packetLength = (int)stream.Length;
                        fCoalesceStream.SetLength(fCoalesceStream.Length + packetLength);
                        fCoalesceStream.Write(stream.GetBuffer(), 0, packetLength);
                    }
                    else // Send to the server now
                    {
                        byte[] packet = stream.GetBuffer();
                        if (fChannel.PacketEncoder != null)
                            fChannel.PacketEncoder.EncodeOutgoingPacket(fChannel, ref packet, ref streamLength);
                        Send(packet, streamLength, SocketFlags.None);
                    }
                }

            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        /// <summary>
        /// Sends pending data (if aggregated is active)
        /// </summary>
        internal void SendAllPending()
        {
            if (fCoalesceStream != null && fCoalesceStream.Length > 0)
            {
                Send(fCoalesceStream.GetBuffer(), (int)fCoalesceStream.Length, SocketFlags.None);
                fCoalesceStream.SetLength(0);
                fCoalesceStream.Position = 0;
            }
        }

        /// <summary>
        /// Performs a check if it can receive the data then receives, reads packets & dispatches the envents
        /// </summary>
        internal void Receive()
        {
            int availableBytes = Available;
            if (availableBytes == 0)
                return;

            byte[] received = new byte[availableBytes];
            int readBytes = Receive(received, availableBytes, SocketFlags.None);

            if (fChannel.PacketEncoder != null)
                fChannel.PacketEncoder.DecodeIncomingPacket(fChannel, ref received, ref readBytes);

            int bufferSize = readBytes + fBuffer.Length;
            using (MemoryStream data = new MemoryStream(bufferSize))
            {
                if (fPartialRecord)
                {
                    data.Write(fBuffer, 0, fBuffer.Length);
                    fPartialRecord = false;
                }

                data.Write(received, 0, readBytes);
                data.Position = 0;

                // While we have data to read
                while (data.Position < data.Length)
                {
                    if (data.Length - data.Position < Packet.HeaderLengthSize)
                    {
                        // Bad situation, we don't even have the full packet here.
                        // Read the partial packet (few bytes)
                        fBuffer = new byte[data.Length - data.Position];
                        data.Read(fBuffer, 0, fBuffer.Length);
                        fPartialRecord = true;
                        break;
                    }

                    int Length = ChannelBase.ReadLength(data) + Packet.HeaderLengthSize;
                    data.Position -= Packet.HeaderLengthSize;

                    // If we have enough data to form a full packet.
                    if (Length <= (data.Length - data.Position))
                    {
                        // Read the operation and read the actual message into a new buffer
                        int messageLength = ChannelBase.ReadLength(data); // UNUSED
                        string operation  = ChannelBase.ReadKey(data);

                        // Reset the reader and read the bytes from the socket into its buffer
                        byte[] readBuffer = fReader.Reset(Length - Packet.HeaderSize);
                        data.Read(readBuffer, 0, Length - Packet.HeaderSize);

                        // Dispatch the event
                        object fullPacket = OperationReaderBase.Instance.Read(operation, fReader);
                        fReader.Release();
                        fChannel.OnReceive(new ChannelReceiveEventArgs(operation, fullPacket));
                    }
                    else
                    {
                        // Read the partial packet
                        fBuffer = new byte[data.Length - data.Position];
                        data.Read(fBuffer, 0, fBuffer.Length);
                        fPartialRecord = true;
                    }
                }
            }
        }

        /// <summary>
        /// Checks whether the current <see cref="TcpSocket"/> is connected or not.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                try
                {
                    bool part1 = this.Poll(1000, SelectMode.SelectRead);
                    bool part2 = this.Available == 0;
                    if (part1 & part2)
                        return false;
                    return true;
                }
                catch(Exception)
                {
                    return false;
                }
            }
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (fCoalesceStream != null)
                fCoalesceStream.Dispose();
        }

    }




   public class ParameterEntity : IEntity
   {
      public ParameterEntity()
      {
      }


      private String fKey;
      public String Key
      {
         set
         {
            fKey = value;
         }
         get
         {
            return fKey;
         }
      }

      private Object fValue;
      public Object Value
      {
         set
         {
            fValue = value;
         }
         get
         {
            return fValue;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
         Writer.WriteDynamic(Value);
      }


      public void Read(PacketReader Reader)
      {
              this.Key = Reader.ReadString();
              this.Value = Reader.ReadDynamic();

      }

   }




   public class CheckRequest : Packet, IPacket
   {
      public CheckRequest() : base("01562224")
      {
      }


      private String fKey;
      public String Key
      {
         set
         {
            fKey = value;
         }
         get
         {
            return fKey;
         }
      }

      private Object fValue;
      public Object Value
      {
         set
         {
            fValue = value;
         }
         get
         {
            return fValue;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
         Writer.WriteDynamic(Value);
      }


      public void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
         this.Value = Reader.ReadDynamic();
      }

   }




   public class GetRequest : Packet, IPacket
   {
      public GetRequest() : base("3E05ECEE")
      {
      }


      private String fKey;
      public String Key
      {
         set
         {
            fKey = value;
         }
         get
         {
            return fKey;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Key);
      }


      public void Read(PacketReader Reader)
      {
         this.Key = Reader.ReadString();
      }

   }




   public class GetAllInform : Packet, IPacket
   {
      public GetAllInform() : base("B22E7270")
      {
      }


      private List<ParameterEntity> fTable;
      public List<ParameterEntity> Table
      {
         set
         {
            fTable = value;
         }
         get
         {
            return fTable;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write<ParameterEntity>(Table);
      }


      public void Read(PacketReader Reader)
      {
         this.Table = Reader.ReadListOfEntity<ParameterEntity>();
      }

   }




   public class CheckInform : Packet, IPacket
   {
      public CheckInform() : base("01562224")
      {
      }


      private Boolean fSuccess;
      public Boolean Success
      {
         set
         {
            fSuccess = value;
         }
         get
         {
            return fSuccess;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Success);
      }


      public void Read(PacketReader Reader)
      {
         this.Success = Reader.ReadBoolean();
      }

   }




   public class GetInform : Packet, IPacket
   {
      public GetInform() : base("3E05ECEE")
      {
      }


      private Object fValue;
      public Object Value
      {
         set
         {
            fValue = value;
         }
         get
         {
            return fValue;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.WriteDynamic(Value);
      }


      public void Read(PacketReader Reader)
      {
         this.Value = Reader.ReadDynamic();
      }

   }




   public class EventInform : Packet, IPacket
   {
      public EventInform() : base("BA220D80")
      {
      }


      private String fMessage;
      public String Message
      {
         set
         {
            fMessage = value;
         }
         get
         {
            return fMessage;
         }
      }

      private DateTime fTime;
      public DateTime Time
      {
         set
         {
            fTime = value;
         }
         get
         {
            return fTime;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Message);
         Writer.Write(Time);
      }


      public void Read(PacketReader Reader)
      {
         this.Message = Reader.ReadString();
         this.Time = Reader.ReadDateTime();
      }

   }




   public class SupplyCredentialsRequest : Packet, IPacket
   {
      public SupplyCredentialsRequest() : base("8D98E9FC")
      {
      }


      private String fCredentialsUri;
      public String CredentialsUri
      {
         set
         {
            fCredentialsUri = value;
         }
         get
         {
            return fCredentialsUri;
         }
      }

      private String fCredentialsType;
      public String CredentialsType
      {
         set
         {
            fCredentialsType = value;
         }
         get
         {
            return fCredentialsType;
         }
      }

      private String fUserName;
      public String UserName
      {
         set
         {
            fUserName = value;
         }
         get
         {
            return fUserName;
         }
      }

      private String fPassword;
      public String Password
      {
         set
         {
            fPassword = value;
         }
         get
         {
            return fPassword;
         }
      }

      private String fDomain;
      public String Domain
      {
         set
         {
            fDomain = value;
         }
         get
         {
            return fDomain;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(CredentialsUri);
         Writer.Write(CredentialsType);
         Writer.Write(UserName);
         Writer.Write(Password);
         Writer.Write(Domain);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.CredentialsUri = Reader.ReadString();
         this.CredentialsType = Reader.ReadString();
         this.UserName = Reader.ReadString();
         this.Password = Reader.ReadString();
         this.Domain = Reader.ReadString();
      }

   }




   public class RevokeCredentialsRequest : Packet, IPacket
   {
      public RevokeCredentialsRequest() : base("4AC51818")
      {
      }


      private String fCredentialsUri;
      public String CredentialsUri
      {
         set
         {
            fCredentialsUri = value;
         }
         get
         {
            return fCredentialsUri;
         }
      }

      private String fCredentialsType;
      public String CredentialsType
      {
         set
         {
            fCredentialsType = value;
         }
         get
         {
            return fCredentialsType;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(CredentialsUri);
         Writer.Write(CredentialsType);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.CredentialsUri = Reader.ReadString();
         this.CredentialsType = Reader.ReadString();
      }

   }




   public class JoinHubRequest : Packet, IPacket
   {
      public JoinHubRequest() : base("1073F46A")
      {
      }


      private String fHubName;
      public String HubName
      {
         set
         {
            fHubName = value;
         }
         get
         {
            return fHubName;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(HubName);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.HubName = Reader.ReadString();
      }

   }




   public class LeaveHubRequest : Packet, IPacket
   {
      public LeaveHubRequest() : base("0BF04B24")
      {
      }


      private String fHubName;
      public String HubName
      {
         set
         {
            fHubName = value;
         }
         get
         {
            return fHubName;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(HubName);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.HubName = Reader.ReadString();
      }

   }




   public class PingInform : Packet, IPacket
   {
      public PingInform() : base("26792C94")
      {
      }


      private Boolean fPong;
      public Boolean Pong
      {
         set
         {
            fPong = value;
         }
         get
         {
            return fPong;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Pong);
      }


      public void Read(PacketReader Reader)
      {
         this.Pong = Reader.ReadBoolean();
      }

   }




   public class GetServerTimeInform : Packet, IPacket
   {
      public GetServerTimeInform() : base("33E7FBD1")
      {
      }


      private DateTime fServerTime;
      public DateTime ServerTime
      {
         set
         {
            fServerTime = value;
         }
         get
         {
            return fServerTime;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(ServerTime);
      }


      public void Read(PacketReader Reader)
      {
         Reader.Decompress();
         this.ServerTime = Reader.ReadDateTime();
      }

   }




   public class SupplyCredentialsInform : Packet, IPacket
   {
      public SupplyCredentialsInform() : base("8D98E9FC")
      {
      }


      private Boolean fResult;
      public Boolean Result
      {
         set
         {
            fResult = value;
         }
         get
         {
            return fResult;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Result);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.Result = Reader.ReadBoolean();
      }

   }




   public class RevokeCredentialsInform : Packet, IPacket
   {
      public RevokeCredentialsInform() : base("4AC51818")
      {
      }


      private Boolean fResult;
      public Boolean Result
      {
         set
         {
            fResult = value;
         }
         get
         {
            return fResult;
         }
      }

      public void Write(PacketWriter Writer)
      {
         Writer.Write(Result);
         Writer.Compress();
      }


      public void Read(PacketReader Reader)
      {
         this.Result = Reader.ReadBoolean();
      }

   }





   internal sealed class OperationReader : OperationReaderBase
   {
      static OperationReader()
      {
         OperationReaderBase.SetInstance(new OperationReader());
      }

      /// <summary>
      /// This method is generated and called automatically, allows read operation calls
      /// </summary>
      internal override object Read(string operationKey, PacketReader reader)
      {
         switch (operationKey)
         {

            case "01562224":
               CheckInform packet01562224 = new CheckInform();
               packet01562224.Read(reader);
            return packet01562224;

            case "26792C94":
               PingInform packet26792C94 = new PingInform();
               packet26792C94.Read(reader);
            return packet26792C94;

            case "33E7FBD1":
               GetServerTimeInform packet33E7FBD1 = new GetServerTimeInform();
               packet33E7FBD1.Read(reader);
            return packet33E7FBD1;

            case "3E05ECEE":
               GetInform packet3E05ECEE = new GetInform();
               packet3E05ECEE.Read(reader);
            return packet3E05ECEE;

            case "4AC51818":
               RevokeCredentialsInform packet4AC51818 = new RevokeCredentialsInform();
               packet4AC51818.Read(reader);
            return packet4AC51818;

            case "8D98E9FC":
               SupplyCredentialsInform packet8D98E9FC = new SupplyCredentialsInform();
               packet8D98E9FC.Read(reader);
            return packet8D98E9FC;

            case "B22E7270":
               GetAllInform packetB22E7270 = new GetAllInform();
               packetB22E7270.Read(reader);
            return packetB22E7270;

            case "BA220D80":
               EventInform packetBA220D80 = new EventInform();
               packetBA220D80.Read(reader);
            return packetBA220D80;
         }
         return null;
      }
   }





   public class TcpChannel : TcpChannelBase
   {
      public TcpChannel() : base()
      {
         if(OperationReaderBase.Instance == null)
            OperationReaderBase.SetInstance(new OperationReader());
      }

      private bool fDispatchInformOnlyOnRequest = true;

      /// <summary>
      /// By default will dispatch the Inform only for a request
      /// was issued (flag applies for pull operations only)
      /// </summary>
      public bool DispatchInformOnlyOnRequest
      {
      get{ return fDispatchInformOnlyOnRequest;}
      set{ fDispatchInformOnlyOnRequest = value;}
      }

      private int fRequestedCheckInform = 0;
      private int fRequestedPingInform = 0;
      private int fRequestedGetServerTimeInform = 0;
      private int fRequestedGetInform = 0;
      private int fRequestedRevokeCredentialsInform = 0;
      private int fRequestedSupplyCredentialsInform = 0;
      private int fRequestedGetAllInform = 0;

      public event EventHandler<PacketReceiveEventArgs<CheckInform>> CheckInform;
      private void OnCheckInform(CheckInform packet)
      {
         if (CheckInform != null)
         CheckInform(this, new PacketReceiveEventArgs<CheckInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<PingInform>> PingInform;
      private void OnPingInform(PingInform packet)
      {
         if (PingInform != null)
         PingInform(this, new PacketReceiveEventArgs<PingInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<GetServerTimeInform>> GetServerTimeInform;
      private void OnGetServerTimeInform(GetServerTimeInform packet)
      {
         if (GetServerTimeInform != null)
         GetServerTimeInform(this, new PacketReceiveEventArgs<GetServerTimeInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<GetInform>> GetInform;
      private void OnGetInform(GetInform packet)
      {
         if (GetInform != null)
         GetInform(this, new PacketReceiveEventArgs<GetInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<RevokeCredentialsInform>> RevokeCredentialsInform;
      private void OnRevokeCredentialsInform(RevokeCredentialsInform packet)
      {
         if (RevokeCredentialsInform != null)
         RevokeCredentialsInform(this, new PacketReceiveEventArgs<RevokeCredentialsInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<SupplyCredentialsInform>> SupplyCredentialsInform;
      private void OnSupplyCredentialsInform(SupplyCredentialsInform packet)
      {
         if (SupplyCredentialsInform != null)
         SupplyCredentialsInform(this, new PacketReceiveEventArgs<SupplyCredentialsInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<GetAllInform>> GetAllInform;
      private void OnGetAllInform(GetAllInform packet)
      {
         if (GetAllInform != null)
         GetAllInform(this, new PacketReceiveEventArgs<GetAllInform>(packet));
      }
      public event EventHandler<PacketReceiveEventArgs<EventInform>> EventInform;
      private void OnEventInform(EventInform packet)
      {
         if (EventInform != null)
         EventInform(this, new PacketReceiveEventArgs<EventInform>(packet));
      }

      /// <summary>
      /// 
      /// </summary>
      public void Check(String Key, Object Value      )
      {
         CheckRequest requestPacket = new CheckRequest();
         requestPacket.Key = Key;
requestPacket.Value = Value;
         fRequestedCheckInform ++;
         base.Send("01562224", requestPacket);
      }

      /// <summary>
      /// Leaves a hub/room.
      /// </summary>
      public void LeaveHub(String HubName      )
      {
         LeaveHubRequest requestPacket = new LeaveHubRequest();
         requestPacket.HubName = HubName;
         base.Send("0BF04B24", requestPacket);
      }

      /// <summary>
      /// Joins a hub/room.
      /// </summary>
      public void JoinHub(String HubName      )
      {
         JoinHubRequest requestPacket = new JoinHubRequest();
         requestPacket.HubName = HubName;
         base.Send("1073F46A", requestPacket);
      }

      /// <summary>
      /// Pings the server
      /// </summary>
      public void Ping()
      {
         fRequestedPingInform ++;
         base.Send("26792C94", null);
      }


      /// <summary>
      /// Gets the time on the server
      /// </summary>
      public void GetServerTime()
      {
         fRequestedGetServerTimeInform ++;
         base.Send("33E7FBD1", null);
      }


      /// <summary>
      /// 
      /// </summary>
      public void Get(String Key      )
      {
         GetRequest requestPacket = new GetRequest();
         requestPacket.Key = Key;
         fRequestedGetInform ++;
         base.Send("3E05ECEE", requestPacket);
      }

      /// <summary>
      /// Revokes the credentials from the requesting channel.
      /// </summary>
      public void RevokeCredentials(String CredentialsUri, String CredentialsType      )
      {
         RevokeCredentialsRequest requestPacket = new RevokeCredentialsRequest();
         requestPacket.CredentialsUri = CredentialsUri;
requestPacket.CredentialsType = CredentialsType;
         fRequestedRevokeCredentialsInform ++;
         base.Send("4AC51818", requestPacket);
      }

      /// <summary>
      /// Supplies the requesting channel with the specified client credentials.
      /// </summary>
      public void SupplyCredentials(String CredentialsUri, String CredentialsType, String UserName, String Password, String Domain      )
      {
         SupplyCredentialsRequest requestPacket = new SupplyCredentialsRequest();
         requestPacket.CredentialsUri = CredentialsUri;
requestPacket.CredentialsType = CredentialsType;
requestPacket.UserName = UserName;
requestPacket.Password = Password;
requestPacket.Domain = Domain;
         fRequestedSupplyCredentialsInform ++;
         base.Send("8D98E9FC", requestPacket);
      }

      /// <summary>
      /// 
      /// </summary>
      public void GetAll()
      {
         fRequestedGetAllInform ++;
         base.Send("B22E7270", null);
      }


      /// <summary>
      /// Sends a subscribe/unsubscribe request for the operation ().
      /// </summary>
      public void SubscribeToEvent()
      {
         base.Send("BA220D80", null);
      }


      /// <summary>
      /// Sends a subscribe/unsubscribe request for the operation ()
      /// </summary>
      public void UnsubscribeFromEvent()
      {
         base.Send("BA220D80", null);
      }

      /// <summary>
      /// This method is automatically generated and allows event dispatching when a packet received
      /// </summary>
      internal override void OnReceive(ChannelReceiveEventArgs e)
      {
         switch (e.Operation)
         {
            case "01562224":
            if((fDispatchInformOnlyOnRequest && fRequestedCheckInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedCheckInform --;
               OnCheckInform(e.Packet as CheckInform);
            }
            return;
            case "26792C94":
            if((fDispatchInformOnlyOnRequest && fRequestedPingInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedPingInform --;
               OnPingInform(e.Packet as PingInform);
            }
            return;
            case "33E7FBD1":
            if((fDispatchInformOnlyOnRequest && fRequestedGetServerTimeInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedGetServerTimeInform --;
               OnGetServerTimeInform(e.Packet as GetServerTimeInform);
            }
            return;
            case "3E05ECEE":
            if((fDispatchInformOnlyOnRequest && fRequestedGetInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedGetInform --;
               OnGetInform(e.Packet as GetInform);
            }
            return;
            case "4AC51818":
            if((fDispatchInformOnlyOnRequest && fRequestedRevokeCredentialsInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedRevokeCredentialsInform --;
               OnRevokeCredentialsInform(e.Packet as RevokeCredentialsInform);
            }
            return;
            case "8D98E9FC":
            if((fDispatchInformOnlyOnRequest && fRequestedSupplyCredentialsInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedSupplyCredentialsInform --;
               OnSupplyCredentialsInform(e.Packet as SupplyCredentialsInform);
            }
            return;
            case "B22E7270":
            if((fDispatchInformOnlyOnRequest && fRequestedGetAllInform > 0) || !fDispatchInformOnlyOnRequest)
            {
               // Mask the request as terminated and dispatch the event
               fRequestedGetAllInform --;
               OnGetAllInform(e.Packet as GetAllInform);
            }
            return;
            case "BA220D80":
            OnEventInform(e.Packet as EventInform);
            return;
         }
      }

      private const int PingRequests = 11;
      private int fPingTest = 0;
      private DateTime[] fPingStarts = new DateTime[PingRequests];
      private uint[] fPingResults = new uint[PingRequests];
      public event EventHandler<LatencyComputedEventArgs> LatencyComputed;

      /// <summary>
      /// Computes the latency (Ping) by sending 10 request to the server and averaging the results
      /// </summary>
      public void ComputeLatency()
      {
         fPingTest = 0;
         fPingStarts[0] = DateTime.Now;
         PingInform += PongReceived;
         Ping();
      }

      private void PongReceived(object sender, PacketReceiveEventArgs<PingInform> e)
      {
         fPingResults[fPingTest] = (uint)((DateTime.Now - fPingStarts[fPingTest]).TotalMilliseconds);
         fPingTest++;
         if (fPingTest < PingRequests)
         {
            // Send more
            fPingStarts[fPingTest] = DateTime.Now;
            Ping();
         }
         else
         {
            // Compute the average latency
            double median = 0;
            for (int i = 1; i < PingRequests; i++)
            median += (double)fPingResults[i] / PingRequests;

            if(LatencyComputed != null)
            LatencyComputed(null, new LatencyComputedEventArgs(Convert.ToUInt32(median)));
         }
      }
   }


}
